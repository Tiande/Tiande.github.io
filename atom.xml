<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天德池]]></title>
  <subtitle><![CDATA[这里不是洗澡的地方]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tiandechi.com/"/>
  <updated>2015-05-20T10:49:43.544Z</updated>
  <id>http://tiandechi.com/</id>
  
  <author>
    <name><![CDATA[钢仔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[11个让你吃惊的Linux终端命令]]></title>
    <link href="http://tiandechi.com/2015/05/20/11%E4%B8%AA%E8%AE%A9%E4%BD%A0%E5%90%83%E6%83%8A%E7%9A%84Linux%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
    <id>http://tiandechi.com/2015/05/20/11个让你吃惊的Linux终端命令/</id>
    <published>2015-05-20T10:48:19.000Z</published>
    <updated>2015-05-20T10:49:43.544Z</updated>
    <content type="html"><![CDATA[<h1 id="命令行日常系快捷键">命令行日常系快捷键</h1><p>如下的快捷方式非常有用，能够极大的提升你的工作效率：</p>
<ul>
<li>CTRL + U - 剪切光标前的内容</li>
<li>CTRL + K - 剪切光标至行末的内容</li>
<li>CTRL + Y - 粘贴</li>
<li>CTRL + E - 移动光标到行末</li>
<li>CTRL + A - 移动光标到行首</li>
<li>ALT + F - 跳向下一个空格</li>
<li>ALT + B - 跳回上一个空格</li>
<li>ALT + Backspace - 删除前一个单词</li>
<li>CTRL + W - 剪切光标后一个单词</li>
<li>Shift + Insert - 向终端内粘贴文本</li>
</ul>
<h1 id="SUDO_!!">SUDO !!</h1><p>如果你还不知道这个命令，我觉得你应该好好感谢我，因为如果你不知道的话，那每次你在输入长串命令后看到“permission denied”后一定会痛苦不堪。<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function_or_atom">sudo</span> <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span>  #会用 <span class="function_or_atom">sudo</span> 的形式运行上一条命令</span><br></pre></td></tr></table></figure></p>
<h1 id="暂停并在后台运行命令">暂停并在后台运行命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CTRL + Z <span class="comment"># 暂停应用程序</span></span><br><span class="line"><span class="built_in">fg</span> <span class="comment"># 重新将程序唤到前台</span></span><br></pre></td></tr></table></figure>
<h1 id="使用nohup">使用nohup</h1><p>在登出SSH会话后仍运行命令<br>如果你用ssh登录别的机器时，nohup命令真的非常有用。<br>那么怎么使用nohup呢？<br>想象一下你使用ssh远程登录到另一台电脑上，你运行了一条非常耗时的命令然后退出了ssh会话，不过命令仍在执行。而nohup可以将这一场景变成现实。</p>
<h1 id="‘在’特定的时间运行Linux命令">‘在’特定的时间运行Linux命令</h1><p>‘nohup’命令在你用SSH连接到服务器，并在上面保持执行SSH登出前任务的时候十分有用。<br>想一下如果你需要在特定的时间执行相同的命令，这种情况该怎么办呢？<br>命令‘at’就能妥善解决这一情况。以下是‘at’使用示例。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">at</span> <span class="number">10</span>:<span class="number">38</span> PM Fri</span><br><span class="line"><span class="keyword">at</span>&gt; cowsay <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">at</span>&gt; CTRL + D</span><br></pre></td></tr></table></figure></p>
<p>上面的命令能在周五下午10时38分运行程序cowsay。<br>使用的语法就是‘at’后追加日期时间。当at&gt;提示符出现后就可以输入你想在那个时间运行的命令了。<br>CTRL + D 返回终端。<br>还有许多日期和时间的格式，都需要你好好翻一翻‘at’的man手册来找到更多的使用方式。</p>
<h1 id="Man手册">Man手册</h1><p>Man手册会为你列出命令和参数的使用大纲，教你如何使用她们。Man手册看起来沉闷呆板。（我思忖她们也不是被设计来娱乐我们的）。<br>不过这不代表你不能做些什么来使她们变得漂亮些。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PAGER=most</span><br></pre></td></tr></table></figure></p>
<p>你需要安装 ‘most’；她会使你的你的man手册的色彩更加绚丽。<br>你可以用以下命令给man手册设定指定的行长：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MANWIDTH=<span class="number">80</span></span><br></pre></td></tr></table></figure></p>
<p>最后，如果你有一个可用的浏览器，你可以使用-H在默认浏览器中打开任意的man页。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -H &lt;<span class="command"><span class="keyword">command</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意啦，以上的命令只有在你将默认的浏览器设置到环境变量$BROWSER中了之后才效果哟。</p>
<h1 id="使用htop查看和管理进程">使用htop查看和管理进程</h1><p>你用哪个命令找出电脑上正在运行的进程的呢？我敢打赌是‘ps’并在其后加不同的参数来得到你所想要的不同输出。<br>安装‘htop’吧！绝对让你相见恨晚。<br>htop在终端中将进程以列表的方式呈现，有点类似于Windows中的任务管理器。你可以使用功能键的组合来切换排列的方式和展示出来的项。你也可以在htop中直接杀死进程。<br>在终端中简单的输入htop即可运行。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop</span><br></pre></td></tr></table></figure></p>
<h1 id="使用ranger浏览文件系统">使用ranger浏览文件系统</h1><p>如果说htop是命令行进程控制的好帮手，那么ranger就是命令行浏览文件系统的好帮手。<br>你在用之前可能需要先安装，不过一旦安装了以后就可以在命令行输入以下命令启动她：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ranger</span><br></pre></td></tr></table></figure></p>
<p>在命令行窗口中ranger和一些别的文件管理器很像，但是相比上下结构布局，她是左右结构的，这意味着你按左方向键你将前进到上一个文件夹，而右方向键则会切换到下一个。<br>在使用前ranger的man手册还是值得一读的，这样你就可以用快捷键操作ranger了。</p>
<h1 id="取消关机">取消关机</h1><p>无论是在命令行还是图形用户界面关机后，才发现自己不是真的想要关机。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">shutdown</span> -c</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，如果关机已经开始则有可能来不及停止关机。<br>以下是另一个可以尝试命令：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pkill</span> shutdown</span><br></pre></td></tr></table></figure></p>
<h1 id="杀死挂起进程">杀死挂起进程</h1><p>想象一下，你正在运行的应用程序不明原因的僵死了。<br>你可以使用<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ps</span> -ef</span><br></pre></td></tr></table></figure></p>
<p>来找到该进程后杀掉或者使用‘htop’。<br>有一个更快、更容易的命令叫做 <strong>xkill</strong> 。<br>简单的在终端中输入以下命令并在窗口中点击你想杀死的应用程序。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xkill</span><br></pre></td></tr></table></figure></p>
<p>那如果整个系统挂掉了怎么办呢？<br>按住键盘上的‘alt’和‘sysrq’不放，然后慢慢输入以下键：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REISUB</span><br></pre></td></tr></table></figure></p>
<p>这样不按电源键你的计算机也能重启了。</p>
<h1 id="下载Youtube视频">下载Youtube视频</h1><p>一般来说我们大多数人都喜欢看Youtube的视频，也会通过钟爱的播放器播放Youtube的流媒体。<br>如果你需要离线一段时间（比如：从苏格兰南部坐飞机到英格兰南部旅游的这段时间）那么你可能希望下载一些视频到存储设备中，到闲暇时观看。<br>你所要做的就是从包管理器中安装 <strong>youtube-dl</strong> 。<br>你可以用以下命令使用 <strong>youtube-dl</strong> ：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-<span class="tag">dl</span> url-to-video</span><br></pre></td></tr></table></figure></p>
<p>你可以在Youtubu视频页面点击分享链接得到视频的url。只要简单的复制链接在粘帖到命令行就行了（要用shift + insert快捷键哟）。</p>
<h1 id="总结">总结</h1><p>希望你在这篇文章中得到帮助，并且在这11条中找到至少一条让你惊叹“原来可以这样”的技巧。</p>
<p><a href="http://www.linuxidc.com/Linux/2015-05/117414.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="命令行日常系快捷键">命令行日常系快捷键</h1><p>如下的快捷方式非常有用，能够极大的提升你的工作效率：</p>
<ul>
<li>CTRL + U - 剪切光标前的内容</li>
<li>CTRL + K - 剪切光标至行末的内容</li>
<li>CTRL]]>
    </summary>
    
      <category term="commands" scheme="http://tiandechi.com/tags/commands/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQLServer分割字符串]]></title>
    <link href="http://tiandechi.com/2015/05/20/SQLServer%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://tiandechi.com/2015/05/20/SQLServer分割字符串/</id>
    <published>2015-05-20T10:46:52.000Z</published>
    <updated>2015-05-20T10:48:00.095Z</updated>
    <content type="html"><![CDATA[<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">CREATE</span> function [dbo].[<span class="constant">SplitStr</span>]</span><br><span class="line">(</span><br><span class="line">     <span class="variable">@SourceStr</span> nvarchar(<span class="number">4000</span>),</span><br><span class="line">     <span class="variable">@Split</span> nvarchar(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line">     returns <span class="variable">@temp</span> table (<span class="constant">Result</span> nvarchar(<span class="number">4000</span>))</span><br><span class="line">as</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">     declare <span class="variable">@ch</span> as nvarchar(<span class="number">4000</span>)</span><br><span class="line">     set          <span class="variable">@SourceStr</span>=<span class="variable">@SourceStr</span>+<span class="variable">@Split</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(<span class="constant">CHARINDEX</span>(<span class="variable">@Split</span>,<span class="variable">@SourceStr</span>,<span class="number">1</span>)&lt;=<span class="number">0</span>)</span><br><span class="line">     <span class="keyword">begin</span></span><br><span class="line">          insert <span class="variable">@temp</span> values(<span class="variable">@SourceStr</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">while</span>(<span class="variable">@SourceStr</span>&lt;&gt;<span class="constant">N</span><span class="string">''</span>)</span><br><span class="line">     <span class="keyword">begin</span></span><br><span class="line">          set          <span class="variable">@ch</span>=<span class="constant">LEFT</span>(<span class="variable">@SourceStr</span>,<span class="constant">CHARINDEX</span>(<span class="variable">@Split</span>,<span class="variable">@SourceStr</span>,<span class="number">1</span>)-<span class="number">1</span>)</span><br><span class="line">          insert     <span class="variable">@temp</span> values(<span class="variable">@ch</span>)</span><br><span class="line">          set          <span class="variable">@SourceStr</span>=<span class="constant">STUFF</span>(<span class="variable">@SourceStr</span>,<span class="number">1</span>,<span class="constant">CHARINDEX</span>(<span class="variable">@Split</span>,<span class="variable">@SourceStr</span>,<span class="number">1</span>),<span class="constant">N</span><span class="string">''</span>)</span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">--select * from splitstr(<span class="constant">N</span><span class="string">'表白怕被拒绝？,拒绝了连朋友都做不成？,那就别表白了,还可以做朋友,做个朋友还可以借钱,借了钱再表白,表白被拒绝了,朋友做不成了,那就不用还钱了,(///▽///)'</span>,<span class="string">','</span>)</span><br><span class="line"><span class="constant">GO</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class=]]>
    </summary>
    
      <category term="SQLServer" scheme="http://tiandechi.com/tags/SQLServer/"/>
    
      <category term="Database" scheme="http://tiandechi.com/categories/Database/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Linux下创建一个不可变更的文件]]></title>
    <link href="http://tiandechi.com/2015/05/20/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%9B%B4%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://tiandechi.com/2015/05/20/如何在Linux下创建一个不可变更的文件/</id>
    <published>2015-05-20T10:44:08.000Z</published>
    <updated>2015-05-20T10:46:31.807Z</updated>
    <content type="html"><![CDATA[<p>假如你想对Linux中的一些重要文件做写保护，这样它们就不能被删除或者被篡改成之前的版本或者其他东西，或者在其他情况下，你可能想避免某些配置文件被软件自动修改。使用chown和chmod命令修改文件的归属关系或者权限位是处理这种情况的一个解决方法，但这并不完美，因为这样无法避免有root权限的操作。这时chattr就派上用场了。</p>
<p>chattr是一个可以设置或取消文件的标志位的Linux命令，它和标准的文件权限（读、写、执行）是分离的。与此相关的另一个命令是lsattr，它可以显示文件的哪些标志位被设置上了。最初只有EXT文件系统（EXT2/3/4）支持chattr和lsattr所管理的标志位，但现在很多其他的原生的Linux文件系统都支持了，比如XFS、Btrfs、ReiserFS等等。</p>
<p>在这个教程中，我会示范如果使用chattr来让Linux中的文件不可变更。</p>
<p>chattr和lsattr命令是e2fsprogs包的一部分，它在所有现代Linux发行版都预装了。</p>
<p>下面是chattr的基本语法。<br><a id="more"></a><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chattr [<span class="link_label">-RVf</span>][<span class="link_reference">操作符</span>][<span class="link_label">标志位</span>]文件...</span><br></pre></td></tr></table></figure></p>
<p>其中操作符可以是“+”（把选定的标志位添加到标志位列表）、“-”（从标志位列表中移除选定的标志位）、或者“=”（强制使用选定的标志位）。</p>
<p>下面是一些可用的标志位。</p>
<p>a: 只能以零来安全删除。（LCTT 译注：一般情况文件被删后内容不会被修改，追加模式打开。<br>A: 不能更新atime（文件访问时间）。<br>c: 当被写入磁盘时被自动压缩。<br>C: 关掉“写时复制”。<br>i: 不可变更。<br>s: 通过自动归改标志位会使得文件被删后原有内容被“0”取代）</p>
<p>&quot;不可变更&quot;标志位</p>
<p>为了让一个文件不可变更，你需要按照如下方法为这个文件添加“不可变更”标志位。例如，对/etc/passwd文件做写保护：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chattr +<span class="tag">i</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>注意设置或取消一个文件的“不可变更”标志位是需要root用户权限的。现在检查该文件“不可变更”标志位是否被添加上了。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>lsattr /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>一旦文件被设置为不可变更，任何用户都将无法修改该文件。即使是root用户也不可以修改、删除、覆盖、移动或者重命名这个文件。如果你想再次修改这个文件，需要先把“不可变更”标志位取消了。</p>
<p>用如下命令取消“不可变更”标志位：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chattr -<span class="tag">i</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>如果你想让一个目录（比如/etc）连同它下边的所有内容不可变更，使用“-R”选项：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chattr -R +<span class="tag">i</span> /etc</span><br></pre></td></tr></table></figure></p>
<p>“只可追加”标志位</p>
<p>另一个有用的的标志位是“只可追加”，它只允许文件内容被追加的方式修改。你不能覆盖或者删除一个设置了“只可追加”标志位的文件。这个标志位在你想避免日志文件被意外清理掉的情况很有用。</p>
<p>和“不可变更”标志位类似，你可以使用如下命令让文件变成“只可追加”模式：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chattr <span class="subst">+</span>a /<span class="built_in">var</span>/<span class="keyword">log</span>/syslog</span><br></pre></td></tr></table></figure></p>
<p>注意当你复制一个“不可变更”或者“只可追加”的文件到其他地方后，新文件不会保留这些标志位！</p>
<p>结论</p>
<p>在这个教程中，我展示了如何使用chattr和lsattr命令来管理额外的文件标志位，来避免文件被篡改（意外或者其他情况）的方法。注意你不能将chattr作为一个安全措施，因为“不可变更”标志位可以很容易被取消掉。解决这个问题的一个可能的方式是限制chattr命令自身的可用性，或者去掉CAPLINUXIMMUTABLE内核权能标志。关于chattr以及可用的标志位的更多细节，请参考它的man手册。</p>
<p><a href="http://www.linuxidc.com/Linux/2015-05/117712.htm" target="_blank" rel="external">Source</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假如你想对Linux中的一些重要文件做写保护，这样它们就不能被删除或者被篡改成之前的版本或者其他东西，或者在其他情况下，你可能想避免某些配置文件被软件自动修改。使用chown和chmod命令修改文件的归属关系或者权限位是处理这种情况的一个解决方法，但这并不完美，因为这样无法避免有root权限的操作。这时chattr就派上用场了。</p>
<p>chattr是一个可以设置或取消文件的标志位的Linux命令，它和标准的文件权限（读、写、执行）是分离的。与此相关的另一个命令是lsattr，它可以显示文件的哪些标志位被设置上了。最初只有EXT文件系统（EXT2/3/4）支持chattr和lsattr所管理的标志位，但现在很多其他的原生的Linux文件系统都支持了，比如XFS、Btrfs、ReiserFS等等。</p>
<p>在这个教程中，我会示范如果使用chattr来让Linux中的文件不可变更。</p>
<p>chattr和lsattr命令是e2fsprogs包的一部分，它在所有现代Linux发行版都预装了。</p>
<p>下面是chattr的基本语法。<br>]]>
    
    </summary>
    
      <category term="chattr" scheme="http://tiandechi.com/tags/chattr/"/>
    
      <category term="lsattr" scheme="http://tiandechi.com/tags/lsattr/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux的五个查找命令]]></title>
    <link href="http://tiandechi.com/2015/05/20/Linux%E7%9A%84%E4%BA%94%E4%B8%AA%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"/>
    <id>http://tiandechi.com/2015/05/20/Linux的五个查找命令/</id>
    <published>2015-05-20T10:32:47.000Z</published>
    <updated>2015-05-20T10:44:39.590Z</updated>
    <content type="html"><![CDATA[<p>最近，我在学习Linux，下面是一些笔记。</p>
<p>使用电脑的时候，经常需要查找文件。</p>
<p>在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。</p>
<a id="more"></a>
<h1 id="find">find</h1><p>find是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。<br>find的使用格式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　$ find <span class="tag">&lt;<span class="title">指定目录</span>&gt;</span> <span class="tag">&lt;<span class="title">指定条件</span>&gt;</span> <span class="tag">&lt;<span class="title">指定动作</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　- <span class="tag">&lt;<span class="title">指定目录</span>&gt;</span>： 所要搜索的目录及其所有子目录。默认为当前目录。</span><br><span class="line"></span><br><span class="line">　　- <span class="tag">&lt;<span class="title">指定条件</span>&gt;</span>： 所要搜索的文件的特征。</span><br><span class="line"></span><br><span class="line">　　- <span class="tag">&lt;<span class="title">指定动作</span>&gt;</span>： 对搜索结果进行特定的处理。</span><br></pre></td></tr></table></figure></p>
<p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。<br>find的使用实例：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ find . -<span class="property">name</span> '<span class="keyword">my</span>*'</span><br></pre></td></tr></table></figure></p>
<p>搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ <span class="keyword">find</span> . -name <span class="string">'my*'</span> -<span class="keyword">ls</span></span><br></pre></td></tr></table></figure></p>
<p>搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ <span class="built_in">find</span> . -<span class="built_in">type</span> f -mmin -<span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。</p>
<h1 id="locate">locate</h1><p>locate命令其实是&quot;find -name&quot;的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</p>
<p>locate命令的使用实例：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="variable">$ </span>locate /etc/sh</span><br></pre></td></tr></table></figure></p>
<p>搜索etc目录下所有以sh开头的文件。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="variable">$ </span>locate ~<span class="regexp">/m</span></span><br></pre></td></tr></table></figure></p>
<p>搜索用户主目录下，所有以m开头的文件。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ locate -<span class="tag">i</span> ~/m</span><br></pre></td></tr></table></figure></p>
<p>搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</p>
<h1 id="whereis">whereis</h1><p>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。<br>whereis命令的使用实例：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="variable">$ </span>whereis grep</span><br></pre></td></tr></table></figure></p>
<h1 id="which">which</h1><p>which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
<p>which命令的使用实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ <span class="built_in">which</span> grep</span><br></pre></td></tr></table></figure></p>
<h1 id="type">type</h1><p>type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p>
<p>type命令的使用实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ <span class="built_in">type</span> <span class="built_in">cd</span></span><br></pre></td></tr></table></figure></p>
<p>系统会提示，cd是shell的自带命令（build-in）。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ <span class="class"><span class="keyword">type</span> <span class="title">grep</span></span></span><br></pre></td></tr></table></figure></p>
<p>系统会提示，grep是一个外部命令，并显示该命令的路径。<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ <span class="class"><span class="keyword">type</span> -<span class="title">p</span> <span class="title">grep</span></span></span><br></pre></td></tr></table></figure></p>
<p>加上-p参数后，就相当于which命令。</p>
<p><a href="http://www.ruanyifeng.com/blog/2009/10/5_ways_to_search_for_files_using_the_terminal.html" target="_blank" rel="external">Source</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近，我在学习Linux，下面是一些笔记。</p>
<p>使用电脑的时候，经常需要查找文件。</p>
<p>在Linux中，有很多方法可以做到这一点。国外网站LinuxHaxor总结了五条命令，你可以看看自己知道几条。大多数程序员，可能经常使用其中的2到3条，对这5条命令都很熟悉的人应该是不多的。</p>]]>
    
    </summary>
    
      <category term="find" scheme="http://tiandechi.com/tags/find/"/>
    
      <category term="locate" scheme="http://tiandechi.com/tags/locate/"/>
    
      <category term="type" scheme="http://tiandechi.com/tags/type/"/>
    
      <category term="whereis" scheme="http://tiandechi.com/tags/whereis/"/>
    
      <category term="which" scheme="http://tiandechi.com/tags/which/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows 7 & Debian 双系统]]></title>
    <link href="http://tiandechi.com/2015/05/18/Windows-7-Debian-%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://tiandechi.com/2015/05/18/Windows-7-Debian-双系统/</id>
    <published>2015-05-18T10:27:14.662Z</published>
    <updated>2015-05-18T10:27:14.662Z</updated>
    <content type="html"><![CDATA[<p><strong>建议在 Linux 下使用一段时间后，再参阅本教程，不然小白会摸不着头脑的。</strong></p>
<h1 id="准备：">准备：</h1><ol>
<li>电脑 #至少一台</li>
<li>U盘 &amp; [移动硬盘,NAS]</li>
<li>下载 Win7 &amp; Debian 的 ISO 安装镜像，备份到移动硬盘<a id="more"></a>
</li>
</ol>
<h1 id="首先安装_Windows_7">首先安装 Windows 7</h1><p><strong>注意：如果当前系统即为 win7 且不想要重装可以跳过这一节。</strong><br><strong>但是硬盘要留出用于装 Debian 的 空分区。（使用 磁盘管理 或是 Diskgenius）</strong></p>
<ol>
<li>将现在系统下自己需要的文件备份到移动硬盘</li>
<li><p><a href="http://blog.chinaunix.net/uid-10328574-id-3526642.html" target="_blank" rel="external">将 ISO 写入 U盘</a><br>windows 下可用 UltraISO 工具；<br><strong>建议下载好主板的驱动到制作好的U盘中。装机后手动安装驱动，避免很多问题</strong><br><strong>万能驱动包 也可以...</strong></p>
<p><strong>Linux 下：</strong></p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#1.用 fdisk 在 U盘 上建立一个 ntfs 分区，编辑 flag ，勾上 boot 选项</span></span><br><span class="line"><span class="preprocessor">#2.然后 mkfs.ntfs 格式化</span></span><br><span class="line"><span class="preprocessor">#3.挂载 win7 的 iso 和新建的 ntfs 分区，并将 iso 的全部内容复制到 ntfs 分区</span></span><br><span class="line"><span class="preprocessor">#4.编译安装ms-sys</span></span><br><span class="line"><span class="preprocessor">#ms-sys是一个写mbr的工具，起到让系统知道能够引导 win7 安装的作用，至关重要. 到 ms-sys.sourceforge.net 下载</span></span><br><span class="line"><span class="preprocessor">#5.运行以下命令写入 mbr ：</span></span><br><span class="line">ms-sys -<span class="number">7</span> /dev/sdX #其中的 -<span class="number">7</span> 参数指 win7 , sdX 指的是U盘对应的盘符</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启， Bios 里改变 硬盘模式 由 AHCI 到 IDE，引导选择 U盘<br>因为必要驱动没装，所以需要 IDE兼容模式，装好系统后可以改回来。</p>
</li>
<li>安装 Windows</li>
<li><a href="http://jingyan.baidu.com/article/e4511cf31556a02b855eaf4c.html" target="_blank" rel="external">Win7 开启 AHCI</a><br>1.在BIOS里SATA模式为IDE的状态下，进入系统后在运行里输入regedit,打开注册表编辑器，依次打开注册表，修改 HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Msahci 下的 start ，把数值数据改为0<br>2.重新启动，在 BIOS 里改成 AHCI 模式，进入系统后会发现新硬件，不用理会，直接安装 AHCI 驱动（ win7 一般联网会自动安装，如没有自动安装，请到主板或笔记本官网下载主板或者单独的 AHCI 驱动）</li>
</ol>
<h1 id="安装Debian"><a href="http://m.blog.chinaunix.net/uid-10995039-id-3142803.html/" target="_blank" rel="external">安装Debian</a></h1><ol>
<li>制作 U盘启动盘<br>使用 UltraISO 即可，此处不再赘述。</li>
<li>U盘引导 开始安装<br><strong>grub 要装在 Linux 所在的分区</strong>（我安装在/dev/sda5）<br>此处不需要在 BIOS 改 硬盘模式， Linux 内核已集成 AHCI 驱动。</li>
<li>重新启动，进入 Win7</li>
</ol>
<h1 id="制作启动引导选项">制作启动引导选项</h1><ol>
<li>安装 EasyBCD</li>
<li>打开 EasyBCD，点击 添加新条目</li>
<li>操作系统: Linux/BSD<br> 类型: GRUB(Legacy)<br> 名称: [自己填]<br> 驱动器： [装 Debian 的那个分区]<br> 【添加条目】</li>
<li>重启，<strong>操作系统选择界面</strong>就有 [自己填] 这个启动选项了。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>建议在 Linux 下使用一段时间后，再参阅本教程，不然小白会摸不着头脑的。</strong></p>
<h1 id="准备：">准备：</h1><ol>
<li>电脑 #至少一台</li>
<li>U盘 &amp; [移动硬盘,NAS]</li>
<li>下载 Win7 &amp; Debian 的 ISO 安装镜像，备份到移动硬盘]]>
    
    </summary>
    
      <category term="Debian" scheme="http://tiandechi.com/tags/Debian/"/>
    
      <category term="Windows" scheme="http://tiandechi.com/tags/Windows/"/>
    
      <category term="OS" scheme="http://tiandechi.com/categories/OS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Debian下iceweasel安装flash player]]></title>
    <link href="http://tiandechi.com/2015/05/18/Debian%E4%B8%8Biceweasel%E5%AE%89%E8%A3%85flash-player/"/>
    <id>http://tiandechi.com/2015/05/18/Debian下iceweasel安装flash-player/</id>
    <published>2015-05-18T10:19:02.000Z</published>
    <updated>2015-05-18T10:20:07.996Z</updated>
    <content type="html"><![CDATA[<p>下载 Flash Player<br>解压会得到一个.so文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#mkdir</span> -<span class="tag">p</span> ~/.mozilla/plugins/</span><br><span class="line">cp libflashplayer<span class="class">.so</span> ~/.mozilla/plugins/</span><br><span class="line">cp libflashplayer<span class="class">.so</span> /usr/lib/iceweasel/</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下载 Flash Player<br>解压会得到一个.so文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><sp]]>
    </summary>
    
      <category term="Debian" scheme="http://tiandechi.com/tags/Debian/"/>
    
      <category term="flash player" scheme="http://tiandechi.com/tags/flash-player/"/>
    
      <category term="iceweasel" scheme="http://tiandechi.com/tags/iceweasel/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用正则表达式]]></title>
    <link href="http://tiandechi.com/2015/05/18/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://tiandechi.com/2015/05/18/常用正则表达式/</id>
    <published>2015-05-18T10:04:29.000Z</published>
    <updated>2015-05-18T10:53:09.043Z</updated>
    <content type="html"><![CDATA[<pre><code>说明：正则表达式通常用于两种任务：<span class="number">1</span>.验证，<span class="number">2</span>.搜索/替换。用于验证时，通常需要在前后分别加上^和<span class="variable">$，</span>以匹配整个待验证字符串；搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和<span class="variable">$。</span>此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。
</code></pre><a id="more"></a>
<table><br><tr><br><th>说明</th><br><th>正则表达式</th><br></tr><br><tr><br><td>网址（URL）</td><br><td><spanclass="regex">[a-zA-z]+://[^\s]<em></em></spanclass="regex"></td><br></tr><br><tr><br><td>IP地址(IPAddress)</td><br><td><spanclass="regex">((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</spanclass="regex"></td><br></tr><br><tr><br><td>电子邮件(Email)</td><br><td><spanclass="regex">\w+([-+.]\w+)@\w+([-.]\w+)<em>.\w+([-.]\w+)</em></spanclass="regex"></td><br></tr><br><tr><br><td>QQ号码</td><br><td><spanclass="regex">[1-9]\d{4,}</spanclass="regex"></td><br></tr><br><tr><br><td>HTML标记(包含内容或自闭合)</td><br><td><spanclass="regex">&lt;(.<em>)(.</em>)&gt;.<em>&lt;\/\1&gt;|&lt;(.</em>)\/&gt;</spanclass="regex"></td><br></tr><br><tr><br><td>密码(由数字/大写字母/小写字母/标点符号组成，四种都必有，8位以上)</td><br><td><spanclass="regex">(?=^.{8,}$)(?=.<em>\d)(?=.</em>\W+)(?=.<em>[A-Z])(?=.</em>[a-z])(?!.<em>\n).</em>$</spanclass="regex"></td><br></tr><br><tr><br><td>日期(年-月-日)</td><br><td><spanclass="regex">(\d{4}|\d{2})-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))</spanclass="regex"></td><br></tr><br><tr><br><td>日期(月/日/年)</td><br><td><spanclass="regex">((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d{4}|\d{2})</spanclass="regex"></td><br></tr><br><tr><br><td>时间(小时:分钟,24小时制)</td><br><td><spanclass="regex">((1|0?)[0-9]|2[0-3]):([0-5][0-9])</spanclass="regex"></td><br></tr><br><tr><br><td>汉字(字符)</td><br><td><spanclass="regex">[\u4e00-\u9fa5]</spanclass="regex"></td><br></tr><br><tr><br><td>中文及全角标点符号(字符)</td><br><td><spanclass="regex">[\u3000-\u301e\ufe10-\ufe19\ufe30-\ufe44\ufe50-\ufe6b\uff01-\uffee]</spanclass="regex"></td><br></tr><br><tr><br><td>中国大陆固定电话号码</td><br><td><spanclass="regex">(\d{4}-|\d{3}-)?(\d{8}|\d{7})</spanclass="regex"></td><br></tr><br><tr><br><td>中国大陆手机号码</td><br><td><spanclass="regex">1\d{10}</spanclass="regex"></td><br></tr><br><tr><br><td>中国大陆邮政编码</td><br><td><spanclass="regex">[1-9]\d{5}</spanclass="regex"></td><br></tr><br><tr><br><td>中国大陆身份证号(15位或18位)</td><br><td><spanclass="regex">\d{15}(\d\d[0-9xX])?</spanclass="regex"></td><br></tr><br><tr><br><td>非负整数(正整数或零)</td><br><td><spanclass="regex">\d+</spanclass="regex"></td><br></tr><br><tr><br><td>正整数</td><br><td><spanclass="regex">[0-9]<em>[1-9][0-9]</em></spanclass="regex"></td><br></tr><br><tr><br><td>负整数</td><br><td><spanclass="regex">-[0-9]<em>[1-9][0-9]</em></spanclass="regex"></td><br></tr><br><tr><br><td>整数</td><br><td><spanclass="regex">-?\d+</spanclass="regex"></td><br></tr><br><tr><br><td>小数</td><br><td><spanclass="regex">(-?\d+)(.\d+)?</spanclass="regex"></td><br></tr><br><tr><br><td>不包含abc的单词</td><br><td><spanclass="regex">\b((?!abc)\w)+\b</spanclass="regex"></td><br></tr><br></table>

<p><a href="http://deerchao.net/tutorials/regex/common.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>说明：正则表达式通常用于两种任务：<span class="number">1</span>.验证，<span class="number">2</span>.搜索/替换。用于验证时，通常需要在前后分别加上^和<span class="variable">$，</span>以匹配整个待验证字符串；搜索/替换时是否加上此限定则根据搜索的要求而定，此外，也有可能要在前后加上\b而不是^和<span class="variable">$。</span>此表所列的常用正则表达式，除个别外均未在前后加上任何限定，请根据需要，自行处理。
</code></pre>]]>
    
    </summary>
    
      <category term="regex" scheme="http://tiandechi.com/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux dd命令制作U盘系统启动盘]]></title>
    <link href="http://tiandechi.com/2015/05/10/Linux-dd%E5%91%BD%E4%BB%A4%E5%88%B6%E4%BD%9CU%E7%9B%98%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    <id>http://tiandechi.com/2015/05/10/Linux-dd命令制作U盘系统启动盘/</id>
    <published>2015-05-10T05:26:41.000Z</published>
    <updated>2015-05-10T05:28:54.000Z</updated>
    <content type="html"><![CDATA[<p>作U盘系统启动盘，Ubuntu下有个图形界面工具Startup Disk Creator，简单易用，但是缺点就是只能制作Ubuntu的启动盘，别的系统不支持。那么我想在Ubuntu下作Fedora的系统启动盘要怎么办呢？不要紧，有dd命令呢！</p>
<p>dd命令是用来拷贝文件的命令，它可以自动转换成对应的格式。在玩树莓派的时候，我们也是用dd命令烧写系统的，还记得吧？<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="tag">dd</span> bs=<span class="number">4</span>M <span class="keyword">if</span>=~/raspberrypi/<span class="number">2014</span>-<span class="number">09</span>-<span class="number">09</span>-wheezy-raspbian<span class="class">.img</span> of=/dev/sdb &amp;&amp; sync</span><br></pre></td></tr></table></figure></p>
<p>dd命令简单用法就是这样，那么我们还可以用它烧写光盘和作其他系统的启动U盘。<br><a id="more"></a><br>在玩树莓派时烧写的文件是img格式的系统镜像，而我们要制作Fedora等Linux发行版通常是iso格式的文件，不要紧，formatting的问题就交给dd命令吧。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="tag">dd</span> --help</span><br><span class="line">Usage: <span class="tag">dd</span> [OPERAND]...</span><br><span class="line">or: <span class="tag">dd</span> OPTION</span><br><span class="line">Copy <span class="tag">a</span> file, converting and formatting according to the operands.</span><br></pre></td></tr></table></figure></p>
<h1 id="过程都是类似的，首先要umount自己的U盘：">过程都是类似的，首先要umount自己的U盘：</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line"><span class="regexp">/dev/</span>sdb1 <span class="number">3.8</span>G <span class="number">880</span>K <span class="number">3.8</span>G <span class="number">1</span>% <span class="regexp">/media/</span>linc/<span class="number">87</span>CD-<span class="number">7</span>F86</span><br><span class="line"></span><br><span class="line">$ umount <span class="regexp">/dev/</span>sdb1</span><br></pre></td></tr></table></figure>
<h1 id="然后就是dd命令烧写：">然后就是dd命令烧写：</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="tag">dd</span> bs=<span class="number">4</span>M <span class="keyword">if</span>=~/linux_images/Fedora-Live-Workstation-i686-<span class="number">21</span>-<span class="number">5</span><span class="class">.iso</span> of=/dev/sdb &amp;&amp; sync</span><br><span class="line">[sudo] password <span class="keyword">for</span> linc:</span><br><span class="line"><span class="number">318</span>+<span class="number">1</span> records <span class="keyword">in</span></span><br><span class="line"><span class="number">318</span>+<span class="number">1</span> records out</span><br><span class="line"><span class="number">1336934400</span> bytes (<span class="number">1.3</span> GB) copied, <span class="number">171.331</span> s, <span class="number">7.8</span> MB/s</span><br></pre></td></tr></table></figure>
<p><strong>注意，dd命令中的目标是sdb，没有标号。</strong></p>
<p><a href="http://www.linuxidc.com/Linux/2015-02/113585.htm" target="_blank" rel="external">source</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作U盘系统启动盘，Ubuntu下有个图形界面工具Startup Disk Creator，简单易用，但是缺点就是只能制作Ubuntu的启动盘，别的系统不支持。那么我想在Ubuntu下作Fedora的系统启动盘要怎么办呢？不要紧，有dd命令呢！</p>
<p>dd命令是用来拷贝文件的命令，它可以自动转换成对应的格式。在玩树莓派的时候，我们也是用dd命令烧写系统的，还记得吧？<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="tag">dd</span> bs=<span class="number">4</span>M <span class="keyword">if</span>=~/raspberrypi/<span class="number">2014</span>-<span class="number">09</span>-<span class="number">09</span>-wheezy-raspbian<span class="class">.img</span> of=/dev/sdb &amp;&amp; sync</span><br></pre></td></tr></table></figure></p>
<p>dd命令简单用法就是这样，那么我们还可以用它烧写光盘和作其他系统的启动U盘。<br>]]>
    
    </summary>
    
      <category term="dd" scheme="http://tiandechi.com/tags/dd/"/>
    
      <category term="启动盘" scheme="http://tiandechi.com/tags/%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[查看Debian的版本信息]]></title>
    <link href="http://tiandechi.com/2015/05/10/%E6%9F%A5%E7%9C%8BDebian%E7%9A%84%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
    <id>http://tiandechi.com/2015/05/10/查看Debian的版本信息/</id>
    <published>2015-05-10T05:06:47.000Z</published>
    <updated>2015-05-10T05:08:04.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor <span class="string">ID:</span> Debian</span><br><span class="line"><span class="string">Description:</span> Debian GNU/Linux testing (squeeze)</span><br><span class="line"><span class="string">Release:</span> testing</span><br><span class="line"><span class="string">Codename:</span> squeeze</span><br><span class="line"></span><br><span class="line">$ cat <span class="regexp">/etc/</span>debian_version</span><br><span class="line">squeeze/sid</span><br></pre></td></tr></table></figure>
<p>/usr/share/doc/base-files/FAQ:</p>
<p>Q. Ok, but how do I know which distribution I&#39;m running?</p>
<p>A. If you are running testing or unstable, then /etc/debian_version is<br>not a reliable way to know that anymore. Looking at the contents of<br>your /etc/apt/sources.list file is probably a much better way.</p>
<p>其他相关的或有趣的包还有：<br><a id="more"></a><br>base-files</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$ </span>linuxinfo<span class="variable">$ </span>linuxlogo</span><br></pre></td></tr></table></figure>
<p>查看内核版本：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cat /<span class="keyword">proc</span>/version</span><br><span class="line"></span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/lbsx/archive/2010/12/29/1920989.html" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor <span class="string">ID:</span> Debian</span><br><span class="line"><span class="string">Description:</span> Debian GNU/Linux testing (squeeze)</span><br><span class="line"><span class="string">Release:</span> testing</span><br><span class="line"><span class="string">Codename:</span> squeeze</span><br><span class="line"></span><br><span class="line">$ cat <span class="regexp">/etc/</span>debian_version</span><br><span class="line">squeeze/sid</span><br></pre></td></tr></table></figure>
<p>/usr/share/doc/base-files/FAQ:</p>
<p>Q. Ok, but how do I know which distribution I&#39;m running?</p>
<p>A. If you are running testing or unstable, then /etc/debian_version is<br>not a reliable way to know that anymore. Looking at the contents of<br>your /etc/apt/sources.list file is probably a much better way.</p>
<p>其他相关的或有趣的包还有：<br>]]>
    
    </summary>
    
      <category term="Debian" scheme="http://tiandechi.com/tags/Debian/"/>
    
      <category term="version" scheme="http://tiandechi.com/tags/version/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to disable Network Manager on Linux]]></title>
    <link href="http://tiandechi.com/2015/05/10/How-to-disable-Network-Manager-on-Linux/"/>
    <id>http://tiandechi.com/2015/05/10/How-to-disable-Network-Manager-on-Linux/</id>
    <published>2015-05-10T05:03:43.000Z</published>
    <updated>2015-05-10T05:12:30.000Z</updated>
    <content type="html"><![CDATA[<p>Network Manager is a feature-rich network configuration service which is used by default in most Linux desktop environments nowadays. It provides automatic configuration of (wired/wireless) network interfaces, as well as VPN, mobile broadband and even Bluetooth connections. Network Manager is smart enough to automatically switch to the best (or the most recent) connection network, and can inform other applications of up-to-date network events via D-Bus API.</p>
<p>While Network Manager comes with various sophisticated features, you might just prefer the old plain network service. There could be several reasons to do so. For one, you may wish to have more control over network management, instead of relying on purely automatic configuration and switch-over, which may or may not suit your needs. Besides, Network Manager is not suitable for advanced networking setup, such as multi-homing to more than one wired connections, forwarding network traffic, configuring Linux bridge or aliases, etc.<br><a id="more"></a><br>In general, Network Manager is designed to keep a typical end-user Linux box connected at all times with the best possible connection with minimum intervention by users. If such automation is not needed in your Linux environment, you can turn off Network Manager.</p>
<p>This tutorial describes how to disable Network Manager in various Linux desktop environments.<br>Check Which Network Interfaces are Managed by Network Manager</p>
<p>To check if Network Manager is managing any network interface, you can use nmcli, which is a command line utility that comes with Network Manager.<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nmcli dev <span class="keyword">status</span></span><br><span class="line"></span><br><span class="line">DEVICE     <span class="keyword">TYPE</span>              STATE</span><br><span class="line">eth1      <span class="number">802</span>-<span class="number">3</span>-ethernet   connected</span><br><span class="line">eth0      <span class="number">802</span>-<span class="number">3</span>-ethernet   connected</span><br></pre></td></tr></table></figure></p>
<p>The above command will list all existing network interfaces along with their STATE. If STATE is shown as &quot;unmanaged&quot;, this means Network Manager is NOT controlling a corresponding interface. If STATE displays any other values (e.g., &quot;connected&quot;), it implies that a given interface is managed by Network Manager.<br>Disable Network Manager Completely</p>
<p>Here is how to disable Network Manager completely, so that Network Manager stops running on your Linux system.</p>
<h1 id="To_disable_Network_Manager_on_Debian:">To disable Network Manager on Debian:</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.<span class="keyword">d</span>/network-manager stop</span><br><span class="line">$ sudo <span class="keyword">update</span>-rc.<span class="keyword">d</span> network-manager remove</span><br></pre></td></tr></table></figure>
<h1 id="To_disable_Network_Manager_on_Ubuntu_or_Linux_Mint:">To disable Network Manager on Ubuntu or Linux Mint:</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo stop network-manager</span><br><span class="line"><span class="variable">$ </span>echo <span class="string">"manual"</span> | sudo tee /etc/init/network-manager.override</span><br></pre></td></tr></table></figure>
<p>After disabling Network Manager on Debian or Ubuntu, use /etc/network/interfaces to configure network interfaces.</p>
<h1 id="To_disable_Network_Manager_on_Fedora:">To disable Network Manager on Fedora:</h1><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="literal">stop</span> <span class="constant">Network</span>Manager.<span class="keyword">service</span></span><br><span class="line">$ sudo systemctl disable <span class="constant">Network</span>Manager.<span class="keyword">service</span></span><br></pre></td></tr></table></figure>
<h1 id="To_disable_Network_Manager_on_CentOS:">To disable Network Manager on CentOS:</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo service <span class="constant">NetworkManager </span>stop</span><br><span class="line"><span class="variable">$ </span>sudo chkconfig <span class="constant">NetworkManager </span>off</span><br></pre></td></tr></table></figure>
<p>After disabling Network Manager on Fedora or CentOS, use /etc/sysconfig/network-scripts/ifcfg-ethX files to configure network interfaces.<br>Disable Network Manager for a Particular Network Interface on Debian, Ubuntu or Linux Mint</p>
<p>To disable Network Manager only for eth1 on Debian, Ubuntu or Linux Mint, you can do the following.</p>
<p>First, open the Network Manager configuration file in /etc/NetworkManager with a text editor, and set &quot;managed=false&quot;, typically shown under [ifupdown].<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo vi /etc/<span class="constant">NetworkManager/NetworkManager.</span>conf</span><br><span class="line"></span><br><span class="line">[ifupdown]</span><br><span class="line">managed=<span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p>Then in /etc/network/interfaces, add information about the interface you want to disable Network Manager for. In this example, the interface is eth1, and we are using static IP configuration.<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># The loopback network interface</span></span><br><span class="line"><span class="type">auto</span> lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># network interface not managed by Network Manager</span></span><br><span class="line">allow-hotplug eth1</span><br><span class="line">iface eth1 inet <span class="keyword">static</span></span><br><span class="line">address <span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">10</span></span><br><span class="line">netmask <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">gateway <span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line">dns-nameservers <span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>Then Network Manager automatically ignore any interfaces specified in /etc/network/interfaces, and stop managing them.</p>
<p>After rebooting, verify that Network Manager is successfully disabled for eth1.<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nmcli dev status</span><br></pre></td></tr></table></figure></p>
<p>Disable Network Manager for a Particular Network Interface on Fedora or CentOS</p>
<p>The following steps will disable Network Manager for eth1 on Fedora, CentOS or RHEL.</p>
<p>Create an interface configuration file for eth1 (if not exist), and add &quot;NM_CONTROLLED=no&quot;.</p>
<p>Enable network service so that eth1 is activated by network service automatically upon boot.<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chkconfig network <span class="function_start"><span class="keyword">on</span></span></span><br></pre></td></tr></table></figure></p>
<p>Upon rebooting, verify that Network Manager is successfully disabled for eth1 with nmcli command.<br>$ nmcli dev status<br><a href="http://xmodulo.com/disable-network-manager-linux.html" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Network Manager is a feature-rich network configuration service which is used by default in most Linux desktop environments nowadays. It provides automatic configuration of (wired/wireless) network interfaces, as well as VPN, mobile broadband and even Bluetooth connections. Network Manager is smart enough to automatically switch to the best (or the most recent) connection network, and can inform other applications of up-to-date network events via D-Bus API.</p>
<p>While Network Manager comes with various sophisticated features, you might just prefer the old plain network service. There could be several reasons to do so. For one, you may wish to have more control over network management, instead of relying on purely automatic configuration and switch-over, which may or may not suit your needs. Besides, Network Manager is not suitable for advanced networking setup, such as multi-homing to more than one wired connections, forwarding network traffic, configuring Linux bridge or aliases, etc.<br>]]>
    
    </summary>
    
      <category term="network-manager" scheme="http://tiandechi.com/tags/network-manager/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux环境获取系统性能数据]]></title>
    <link href="http://tiandechi.com/2015/05/10/Linux%E7%8E%AF%E5%A2%83%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/"/>
    <id>http://tiandechi.com/2015/05/10/Linux环境获取系统性能数据/</id>
    <published>2015-05-10T05:01:52.000Z</published>
    <updated>2015-05-10T05:03:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CPU利用率">CPU利用率</h1><p>/proc/stat文件里包含系统cpu使用情况，2-8列对应的CPU消耗含义是用户态消耗(user)、用户态nice消耗(nice)、内 核态消耗(sys)、空闲时间(idle)、等待IO消耗(iowait)、硬件中断消耗(hardirq)、软中断消耗(softirq)。（man proc）</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cat /<span class="keyword">proc</span>/stat</span><br><span class="line">cpu  <span class="number">2339504870</span> <span class="number">2641995</span> <span class="number">716723851</span> <span class="number">70316975284</span> <span class="number">7219566</span> <span class="number">328971</span> <span class="number">304057999</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu0 <span class="number">211214357</span> <span class="number">275710</span> <span class="number">57674236</span> <span class="number">2778331292</span> <span class="number">3688175</span> <span class="number">10421</span> <span class="number">12279511</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu1 <span class="number">140100049</span> <span class="number">278788</span> <span class="number">47142039</span> <span class="number">2857686940</span> <span class="number">180452</span> <span class="number">32028</span> <span class="number">14960093</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>要计算t1~t2时间内系统的cpu利用率，需要在t1、t2时刻分别采集cpu使用信息<br><a id="more"></a><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1_all = t1<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq)</span></span><br><span class="line">t1_used = t1<span class="list">(<span class="keyword">user</span> + nice + sys + iowait + hardirq + sortirq)</span></span><br><span class="line">t2_all = t2<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq</span><br><span class="line">t2_used = t2<span class="list">(<span class="keyword">user</span> + nice + sys + iowait + hardirq + sortirq)</span></span><br><span class="line"></span><br><span class="line">cpu_usage = <span class="list">(<span class="keyword">t2_used</span> - t1_used)</span> / <span class="list">(<span class="keyword">t2_all</span> - t1_all)</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="进程CPU利用率">进程CPU利用率</h1><p>/proc/$pid/stat文件里包含某个进程的cpu使用信息，14、15、16、17列对应进程用户态消耗(user)、内核态消耗(sys)、用户态等待子进程的消耗(user_child)、内核态等待子进程的消耗(sys_child)。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$cat /<span class="keyword">proc</span>/<span class="number">24076</span>/stat</span><br><span class="line"><span class="number">24076</span> (redis-server) S <span class="number">1</span> <span class="number">24076</span> <span class="number">24076</span> <span class="number">0</span> -<span class="number">1</span> <span class="number">4202560</span> <span class="number">5755</span> <span class="number">147</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1864</span> <span class="number">3298</span> <span class="number">0</span> <span class="number">0</span> <span class="number">20</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">70238536</span> <span class="number">159555584</span> <span class="number">5145</span> <span class="number">18446744073709551615</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4097</span> <span class="number">17610</span> <span class="number">18446744073709551615</span> <span class="number">0</span> <span class="number">0</span> <span class="number">17</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>t1、t2时刻分别采集/proc/stat、/proc/$pid/stat，获取总的cpu消耗，以及进程的cpu消耗<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1_all = t1<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq)</span></span><br><span class="line">t1_pid = t1<span class="list">(<span class="keyword">user</span> + sys + user_child + sys_child)</span></span><br><span class="line">t2_all = t2<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq)</span></span><br><span class="line">t2_pid = t2<span class="list">(<span class="keyword">user</span> + sys + user_child + sys_child)</span></span><br><span class="line"></span><br><span class="line">pid_cpu_usage = <span class="list">(<span class="keyword">t2_pid</span> - t1_pid)</span> / <span class="list">(<span class="keyword">t2_all</span> - t1_all)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="内存利用率">内存利用率</h1><p>/proc/meminfo文件里包含系统内存使用信息</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/meminfo</span><br><span class="line"><span class="type">MemTotal</span>:       <span class="number">198450624</span> kB</span><br><span class="line"><span class="type">MemFree</span>:        <span class="number">184950332</span> kB</span><br><span class="line"></span><br><span class="line">mem_usage = <span class="number">1</span> - <span class="type">MemFree</span> / <span class="type">MemTotal</span></span><br></pre></td></tr></table></figure>
<h1 id="系统load">系统load</h1><p>/proc/uptime的前3列包含了最近1min、5min、15min系统的平均load（正在运行或等待IO的进程数，进程state为R或D）</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cat /<span class="keyword">proc</span>/loadavg</span><br><span class="line"><span class="number">0</span>.<span class="number">02</span> <span class="number">0</span>.<span class="number">09</span> <span class="number">0</span>.<span class="number">08</span> <span class="number">1</span>/<span class="number">2362</span> <span class="number">855</span></span><br></pre></td></tr></table></figure>
<h1 id="网卡流量信息">网卡流量信息</h1><p>/proc/net/dev包含所有网卡的流量信息，第1、2、10、11列分别代表网卡当前接受字节数（recv_bytes）、接受包个数(recv_packets)、发送字节数(send_bytes)、发送个数(send_packets)。</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /<span class="keyword">proc</span>/net/dev<span class="symbol"></span><br><span class="line">Inter-|</span> <span class="symbol">  Receive</span>                                                |<span class="symbol">  Transmit</span></span><br><span class="line"><span class="symbol"> face</span> |bytes<span class="symbol">    packets</span> errs<span class="symbol"> drop</span> fifo<span class="symbol"> frame</span> compressed<span class="symbol"> multicast|bytes</span> <span class="symbol">   packets</span> errs<span class="symbol"> drop</span> fifo<span class="symbol"> colls</span> <span class="symbol">    carrier</span> compressed<span class="symbol"></span><br><span class="line"> lo:25047448261</span> 37947893    0    0    0     0          0         0 25047448261 37947893    0    0    0     0       0          0<span class="symbol"></span><br><span class="line"> eth0:2566932970457</span> 7620547348    0    0    2     0          0     62732 728662220296 6145797287    0    0    0     0       0          0<span class="symbol"></span><br><span class="line"> eth1:2023304550582</span> 7268848253    0    0    0     0          0     77924 742443231982 6129090809    0    0    0     0       0          0</span><br></pre></td></tr></table></figure>
<p>t1~t2时间内的平均流量为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avg_recv_bytes = <span class="list">(<span class="keyword">t2_recv_bytes</span> - t1_recv_bytes)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_send_bytes = <span class="list">(<span class="keyword">t2_send_bytes</span> - t1_send_bytes)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="磁盘（文件系统）空间信息">磁盘（文件系统）空间信息</h1><p>通过statfs系统调用可获取当前文件系统的空间占用情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> statfs &#123;</span><br><span class="line">    <span class="keyword">long</span>    f_type;     <span class="comment">/* type of file system (see below) */</span></span><br><span class="line">    <span class="keyword">long</span>    f_bsize;    <span class="comment">/* optimal transfer block size */</span></span><br><span class="line">    <span class="keyword">long</span>    f_blocks;   <span class="comment">/* total data blocks in file system */</span></span><br><span class="line">    <span class="keyword">long</span>    f_bfree;    <span class="comment">/* free blocks in fs */</span></span><br><span class="line">    <span class="keyword">long</span>    f_bavail;   <span class="comment">/* free blocks avail to non-superuser */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">disk_usage = <span class="number">1</span> - f_bfree / f_blocks</span><br></pre></td></tr></table></figure>
<h1 id="磁盘读写信息">磁盘读写信息</h1><p>/proc/diskstats包含磁盘的IO信息，第4-9列分别为当前磁盘读次数(read)，磁盘读扇区数(read_sec)、磁盘读毫秒数(read_ms)、磁盘写次数(write)、磁盘写扇区数(write_sec)、磁盘写毫秒数(write_ms)。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cat /<span class="keyword">proc</span>/diskstats</span><br><span class="line"><span class="number">8</span>       <span class="number">4</span> sda4 <span class="number">3</span> <span class="number">0</span> <span class="number">12</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span>       <span class="number">5</span> sda5 <span class="number">87928</span> <span class="number">55284</span> <span class="number">2842138</span> <span class="number">17349</span> <span class="number">1230958</span> <span class="number">7932106</span> <span class="number">73380432</span> <span class="number">4931382</span> <span class="number">0</span> <span class="number">503343</span> <span class="number">4947504</span></span><br><span class="line"><span class="number">8</span>      <span class="number">16</span> sdb <span class="number">393</span> <span class="number">35</span> <span class="number">3418</span> <span class="number">37</span> <span class="number">17</span> <span class="number">2</span> <span class="number">152</span> <span class="number">0</span> <span class="number">0</span> <span class="number">37</span> <span class="number">37</span></span><br><span class="line"><span class="number">8</span>      <span class="number">32</span> sdc <span class="number">788</span> <span class="number">114</span> <span class="number">10690</span> <span class="number">10132</span> <span class="number">14550036</span> <span class="number">226568635</span> <span class="number">1929026928</span> <span class="number">623148463</span> <span class="number">0</span> <span class="number">4917530</span> <span class="number">623154797</span></span><br></pre></td></tr></table></figure>
<p>t1~t2时间内磁盘平均读写次数、扇区数、IO利用率计算如下<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avg_read = <span class="list">(<span class="keyword">t2_read</span> - t1_read)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_read_sec = <span class="list">(<span class="keyword">t2_read_sec</span> - t1_read_sec)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_write = <span class="list">(<span class="keyword">t2_write</span> - t1_write)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_write_sec = <span class="list">(<span class="keyword">t2_write_sec</span> - t1_write_sec)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">io_util = <span class="list">(<span class="keyword">t2_read_ms</span> + t2_write_ms - t1_read_ms - t1_write_ms)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span> <span class="list">(<span class="keyword">t1</span>~t2时间段内IO</span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.linuxidc.com/Linux/2015-05/117278.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CPU利用率">CPU利用率</h1><p>/proc/stat文件里包含系统cpu使用情况，2-8列对应的CPU消耗含义是用户态消耗(user)、用户态nice消耗(nice)、内 核态消耗(sys)、空闲时间(idle)、等待IO消耗(iowait)、硬件中断消耗(hardirq)、软中断消耗(softirq)。（man proc）</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cat /<span class="keyword">proc</span>/stat</span><br><span class="line">cpu  <span class="number">2339504870</span> <span class="number">2641995</span> <span class="number">716723851</span> <span class="number">70316975284</span> <span class="number">7219566</span> <span class="number">328971</span> <span class="number">304057999</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu0 <span class="number">211214357</span> <span class="number">275710</span> <span class="number">57674236</span> <span class="number">2778331292</span> <span class="number">3688175</span> <span class="number">10421</span> <span class="number">12279511</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu1 <span class="number">140100049</span> <span class="number">278788</span> <span class="number">47142039</span> <span class="number">2857686940</span> <span class="number">180452</span> <span class="number">32028</span> <span class="number">14960093</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>要计算t1~t2时间内系统的cpu利用率，需要在t1、t2时刻分别采集cpu使用信息<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[win7 32位与64位下载地址存档]]></title>
    <link href="http://tiandechi.com/2015/05/10/win7-32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%AD%98%E6%A1%A3/"/>
    <id>http://tiandechi.com/2015/05/10/win7-32位与64位下载地址存档/</id>
    <published>2015-05-10T04:58:22.000Z</published>
    <updated>2015-05-10T05:12:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Windows_7_简体中文旗舰版_x86_(32位_MSDN_RTM正式版)">Windows 7 简体中文旗舰版 x86 (32位 MSDN RTM正式版)</h1><p><a href="ed2k://%7Cfile%7Ccn_windows_7_ultimate_with_sp1_x86_dvd_618763.iso%7C2651877376%7CD6A0D9FDB8C67A65B92B4C1AC197109C%7C/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_Ultimate_(x64)-DVD(English)">Windows 7 Ultimate (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_x64_dvd_X15-65922.iso|3224686592|6719AFC5486F38BE75F2DF39C8527113|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_Ultimate_N_(x64)-DVD(English)">Windows 7 Ultimate N (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_n_x64_dvd_x16-13641.iso|2908555264|C014B86268602565B7880933B41F21AC|/" target="_blank" rel="external">下载地址</a><br><a id="more"></a></p>
<h1 id="Windows_7_Ultimate_with_Service_Pack_1_(x64)-DVD(English)">Windows 7 Ultimate with Service Pack 1 (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_with_sp1_x64_dvd_618240.iso|3319478272|004498E6851D90B5E025049604942C86|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_Ultimate_with_Service_Pack_1_(x64)-DVD(English)-1">Windows 7 Ultimate with Service Pack 1 (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_with_sp1_x64_dvd_u_677332.iso|3320903680|743598C64E635C72964CF02A3E0AD547|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(简体中文)">Windows 7 旗舰版 (x64)-DVD(简体中文)</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_x64_dvd_x15-66043.iso|3341268992|7DD7FA757CE6D2DB78B6901F81A6907A|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_含SP1(x64)-DVD(简体中文)">Windows 7 旗舰版 含SP1(x64)-DVD(简体中文)</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_618537.iso|3419052032|56E90251E665E643C81168F6DD870BCB|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_含SP1(x64)-DVD(简体中文)-1">Windows 7 旗舰版 含SP1(x64)-DVD(简体中文)</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(中文-香港特别行政区)">Windows 7 旗舰版 (x64)-DVD(中文-香港特别行政区)</h1><p><a href="ed2k://|file|hk_windows_7_ultimate_x64_dvd_x15-65911.iso|3313936384|917F16D04FBBFDE763A35E2A32595AD9|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(中文-香港特别行政区)-1">Windows 7 旗舰版 (x64)-DVD(中文-香港特别行政区)</h1><p><a href="ed2k://|file|hk_windows_7_ultimate_with_sp1_x64_dvd_618544.iso|3390910464|BE5F84D28F5DA939EEFDB9498D4F986D|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(中文-香港特别行政区)-2">Windows 7 旗舰版 (x64)-DVD(中文-香港特别行政区)</h1><p><a href="ed2k://|file|hk_windows_7_ultimate_with_sp1_x64_dvd_u_677411.iso|3392374784|C8DFF761AD8DD1B9137887954942B803|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="win7_32位旗舰版">win7 32位旗舰版</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="win7_64位旗舰版">win7 64位旗舰版</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/" target="_blank" rel="external">下载地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Windows_7_简体中文旗舰版_x86_(32位_MSDN_RTM正式版)">Windows 7 简体中文旗舰版 x86 (32位 MSDN RTM正式版)</h1><p><a href="ed2k://%7Cfile%7Ccn_windows_7_ultimate_with_sp1_x86_dvd_618763.iso%7C2651877376%7CD6A0D9FDB8C67A65B92B4C1AC197109C%7C/">下载地址</a></p>
<h1 id="Windows_7_Ultimate_(x64)-DVD(English)">Windows 7 Ultimate (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_x64_dvd_X15-65922.iso|3224686592|6719AFC5486F38BE75F2DF39C8527113|/">下载地址</a></p>
<h1 id="Windows_7_Ultimate_N_(x64)-DVD(English)">Windows 7 Ultimate N (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_n_x64_dvd_x16-13641.iso|2908555264|C014B86268602565B7880933B41F21AC|/">下载地址</a><br>]]>
    
    </summary>
    
      <category term="32位" scheme="http://tiandechi.com/tags/32%E4%BD%8D/"/>
    
      <category term="64位" scheme="http://tiandechi.com/tags/64%E4%BD%8D/"/>
    
      <category term="Downloads" scheme="http://tiandechi.com/tags/Downloads/"/>
    
      <category term="Win7" scheme="http://tiandechi.com/tags/Win7/"/>
    
      <category term="ed2k" scheme="http://tiandechi.com/tags/ed2k/"/>
    
      <category term="Windows" scheme="http://tiandechi.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[regular expression tutorial in 30 minutes]]></title>
    <link href="http://tiandechi.com/2015/05/04/regular-expression-tutorial-in-30-minutes/"/>
    <id>http://tiandechi.com/2015/05/04/regular-expression-tutorial-in-30-minutes/</id>
    <published>2015-05-04T11:03:17.000Z</published>
    <updated>2015-05-04T03:07:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="本文目标">本文目标</h1><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>
<h1 id="如何使用本教程">如何使用本教程</h1><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。<br>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？<br><a id="more"></a><br><strong>详情查看<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">来源</a></strong></p>
<h1 id="正则表达式到底是什么东西？">正则表达式到底是什么东西？</h1><h1 id="入门">入门</h1><h1 id="测试正则表达式">测试正则表达式</h1><h1 id="元字符">元字符</h1><h1 id="字符转义">字符转义</h1><h1 id="重复">重复</h1><h1 id="字符类">字符类</h1><h1 id="分枝条件">分枝条件</h1><h1 id="反义">反义</h1><h1 id="分组">分组</h1><h1 id="后向引用">后向引用</h1><h1 id="零宽断言">零宽断言</h1><h1 id="负向零宽断言">负向零宽断言</h1><h1 id="注释">注释</h1><h1 id="贪婪与懒惰">贪婪与懒惰</h1><h1 id="处理选项">处理选项</h1><h1 id="平衡组/递归匹配">平衡组/递归匹配</h1><h1 id="还有些什么东西没提到">还有些什么东西没提到</h1><h1 id="联系作者">联系作者</h1><h1 id="网上的资源及本文参考文献">网上的资源及本文参考文献</h1><h1 id="更新纪录">更新纪录</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="本文目标">本文目标</h1><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>
<h1 id="如何使用本教程">如何使用本教程</h1><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。<br>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？<br>]]>
    
    </summary>
    
      <category term="regular expression" scheme="http://tiandechi.com/tags/regular-expression/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log in SSH with no password]]></title>
    <link href="http://tiandechi.com/2015/05/04/log-in-SSH-with-no-password/"/>
    <id>http://tiandechi.com/2015/05/04/log-in-SSH-with-no-password/</id>
    <published>2015-05-04T11:02:11.000Z</published>
    <updated>2015-05-04T03:08:58.000Z</updated>
    <content type="html"><![CDATA[<p>SSH无密码登录要使用公钥与私钥。Linux下可以用用ssh-keygen生成公钥/私钥对，下面我以CentOS为例。</p>
<p>有机器A(192.168.1.155)，B(192.168.1.181)。现想A通过ssh免密码登录到B。<br><a id="more"></a></p>
<h1 id="在A机下生成公钥/私钥对。">在A机下生成公钥/私钥对。</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[linuxidc<span class="variable">@A</span> ~]<span class="variable">$ </span>ssh-keygen -t rsa -<span class="constant">P </span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>-P表示密码，-P &#39;&#39; 就表示空密码，也可以不用-P参数，这样就要三车回车，用-P就一次回车。<br>它在/home/linuxidc下生成.ssh目录，.ssh下有id_rsa和id_rsa.pub。</p>
<h1 id="把A机下的id_rsa-pub复制到B机下，在B机的-ssh/authorized_keys文件里，我用scp复制。">把A机下的id_rsa.pub复制到B机下，在B机的.ssh/authorized_keys文件里，我用scp复制。</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[linuxidc<span class="variable">@A</span> ~]<span class="variable">$ </span>scp .ssh/id_rsa.pub linuxidc<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">181</span><span class="symbol">:/home/linuxidc/id_rsa</span>.pub </span><br><span class="line">linuxidc<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">181</span><span class="string">'s password:</span><br><span class="line">id_rsa.pub 100% 223 0.2KB/s 00:00</span></span><br></pre></td></tr></table></figure>
<p>由于还没有免密码登录的，所以要输入密码。</p>
<h1 id="B机把从A机复制的id_rsa-pub添加到-ssh/authorzied_keys文件里。">B机把从A机复制的id_rsa.pub添加到.ssh/authorzied_keys文件里。</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[linuxidc<span class="variable">@B</span> ~]<span class="variable">$ </span>cat id_rsa.pub <span class="prompt">&gt;&gt; </span>.ssh/authorized_keys</span><br><span class="line">[linuxidc<span class="variable">@B</span> ~]<span class="variable">$ </span>chmod <span class="number">600</span> .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>authorized_keys的权限要是<strong>600</strong>。</p>
<h1 id="A机登录B机。">A机登录B机。</h1><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">linuxidc@A</span> ~]$ ssh <span class="number">192.168</span>.1.181</span><br><span class="line">The authenticity of host <span class="variable">'192.168.1.181</span> <span class="list">(<span class="keyword">192.168.1.181</span>)</span>' can<span class="variable">'t</span> be established.</span><br><span class="line">RSA key fingerprint is <span class="number">00</span>:a6:a8:87:eb:c7:40:10:39:cc:a0:eb:50:d9:6a:5b.</span><br><span class="line">Are you sure you want to continue connecting <span class="list">(<span class="keyword">yes/no</span>)</span>? yes</span><br><span class="line">Warning: Permanently added <span class="variable">'192.168.1.181</span>' <span class="list">(<span class="keyword">RSA</span>)</span> to the list of known hosts.</span><br><span class="line">Last login: Thu Jul <span class="number">3</span> <span class="number">09</span>:53:18 <span class="number">2008</span> from linuxidc</span><br><span class="line"><span class="list">[<span class="keyword">chenlb@B</span> ~]$</span></span></span><br></pre></td></tr></table></figure>
<p>第一次登录是时要你输入yes。</p>
<h1 id="现在A机可以无密码登录B机了。">现在A机可以无密码登录B机了。</h1><p>小结：登录的机子可有私钥，被登录的机子要有登录机子的公钥。这个公钥/私钥对一般在私钥宿主机产生。上面是用rsa算法的公钥/私钥对，当然也可以用dsa(对应的文件是id_dsa，id_dsa.pub)</p>
<p>想让A，B机无密码互登录，那B机以上面同样的方式配置即可。</p>
<p><a href="http://www.linuxidc.com/Linux/2015-05/116908.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SSH无密码登录要使用公钥与私钥。Linux下可以用用ssh-keygen生成公钥/私钥对，下面我以CentOS为例。</p>
<p>有机器A(192.168.1.155)，B(192.168.1.181)。现想A通过ssh免密码登录到B。<br>]]>
    
    </summary>
    
      <category term="SSH" scheme="http://tiandechi.com/tags/SSH/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[find command]]></title>
    <link href="http://tiandechi.com/2015/05/04/find-command/"/>
    <id>http://tiandechi.com/2015/05/04/find-command/</id>
    <published>2015-05-04T10:59:37.000Z</published>
    <updated>2015-05-04T03:01:28.000Z</updated>
    <content type="html"><![CDATA[<p>find 命令算是Linux下最常用的一个命令之一了，这里有一些常用用法的总结。</p>
<ol>
<li><p>按文件名搜索<br>搜索当前目录下所有的以txt结尾的文件。第二个命令用了 -exec 参数，可以在对查找的所有文件执行一种操作。注意格式，空格和;一个都不能少。-name 的参数可以用正则表达式，例如第二个例子</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./* -<span class="property">name</span> <span class="string">"*.txt"</span></span><br><span class="line">find ./* -<span class="property">name</span> <span class="string">"[ab]*.py"</span></span><br><span class="line">find ./* -<span class="property">name</span> <span class="string">"*.pyc"</span> -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按修改时间查找<br>查找当前目录下当天修改过的文件。-1 表示一天前修改过的文件。-2表示前两天。find ./<em> -mtime n n表示，对文件数据的最近一次修改是在 n</em>24 小时之前。+n 指n天以前，-n指n天以内(对 -mmin 是指n分钟), n 表示第n天，他们的含义都是不同的，注意区分。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./* -mtime <span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span> </span><br><span class="line"><span class="built_in">find</span> ./* -mmin -<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br><span class="line"><span class="built_in">find</span> ./* -mmin +<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件状态改变<br>和上个参数相比，基本道理都是一样的，只不过这个参数的含义是文件的权限被修改。改内容和改文件的权限是不一样的，这里指的是更改的是文件inode的数据，比如文件的权限，所属人等等信息。cmin 表示近60分钟内被改过权限，ctime 表示近几天内被修改过。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./* -cmin +<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br><span class="line"><span class="built_in">find</span> ./* -ctime -<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按照文件的所属group和 所属user 来查找<br>-user 和 -nouser 最后一个命令找出当前已经被删除的系统用户的所有文件， - group 和 - nogroup 的功能类似。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./* -user fox</span><br><span class="line"><span class="built_in">find</span> ./* -nouser</span><br></pre></td></tr></table></figure>
</li>
<li><p>find 避开某个目录,避开多个目录。<br>其中 -a 表示 and 的意思，-o 表示or 的意思。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> test -<span class="built_in">path</span> "test/test4" -prune -o -<span class="built_in">print</span></span><br><span class="line"><span class="built_in">find</span> test \( -<span class="built_in">path</span> test/test4 -o -<span class="built_in">path</span> test/test3 \) -prune -o -<span class="built_in">print</span> </span><br><span class="line"><span class="built_in">find</span> . \( -<span class="built_in">path</span> ./modules -o -<span class="built_in">path</span> ./framework -o -<span class="built_in">path</span> ./utils -o -<span class="built_in">path</span> ./config \) -prune -o -name "Bigger.*" -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-perm 选项 指文件的访问权限</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> -perm <span class="number">755</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实用inode 来查找文件编号。可以如下面所示在find命令中指定inode编号。在此，find命令用inode编号重命名了一个文件。你也可以通过rm来删除那个特殊的文件。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -i1 test*</span><br><span class="line">16187429 test-file-name</span><br><span class="line">16187430 test-file-name</span><br><span class="line">find -inum 16187430 -exec mv &#123;&#125;<span class="instruction"> new-test-file-name </span>\;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找出当前目录下最大的5个文件</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="keyword">type</span> f -exec <span class="keyword">ls</span> -s &#123;&#125; \; | <span class="keyword">sort</span> -<span class="keyword">n</span> -r | head -5</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的命令删除大于100M的*.zip文件。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="keyword">type</span> f -<span class="keyword">name</span> *.zip -<span class="built_in">size</span> +00M -exec rm -i &#123;&#125; \;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="http://www.linuxidc.com/Linux/2015-04/116854.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>find 命令算是Linux下最常用的一个命令之一了，这里有一些常用用法的总结。</p>
<ol>
<li><p>按文件名搜索<br>搜索当前目录下所有的以txt结尾的文件。第二个命令用了 -exec 参数，可以在对查找的所有文件执行一种操作。注意格式，空格和;一个都不能少]]>
    </summary>
    
      <category term="commands" scheme="http://tiandechi.com/tags/commands/"/>
    
      <category term="find" scheme="http://tiandechi.com/tags/find/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[how to enter single user mode and crack root password in Linux]]></title>
    <link href="http://tiandechi.com/2015/04/29/how-to-enter-single-user-mode-and-crack-root-password-in-Linux/"/>
    <id>http://tiandechi.com/2015/04/29/how-to-enter-single-user-mode-and-crack-root-password-in-Linux/</id>
    <published>2015-04-29T11:37:52.000Z</published>
    <updated>2015-04-29T03:38:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux下如何进入单人维护模式">linux下如何进入单人维护模式</h1><p>先将系统重新开机，在读秒的时候按下任意键就会出现操作系统的选择画面，仔细看选单底下的说明， 按下『e』就能进入grub的编辑模式了。此時你看到的画面有点像底下这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root (hd0,<span class="number">0</span>)</span><br><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span> ro root=LABEL=/ rhgb quiet</span><br><span class="line">initrd /initrd-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span><span class="class">.img</span></span><br></pre></td></tr></table></figure></p>
<p>此时，请将游标移动到kernel那一行，再按一次『 e 』进入kernel该行的编辑画面中， 然后在出现的画面<br>当中，最后方输入 “single” ：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span>.el5 ro <span class="variable">root=</span><span class="variable">LABEL=</span>/ rhgb quiet single</span><br></pre></td></tr></table></figure></p>
<p>再按下『 Enter 』確定之後，按下 b 就可以开机進入单人维护模式了！<br>在这个模式底下，你会在tty1的地方不需要输入密码即可取得终端机的控制权(而且是使用root的身份喔！)。</p>
<h1 id="各个Linux版本的本地root密码破解方法">各个Linux版本的本地root密码破解方法</h1><a id="more"></a>
<p>这段时间老碰到有人问及各个linux版本的本地root密码破解方法，我这里自己以及在网络上搜集了些资料，希望对看到了这文章而又恰好用得到的技术人员有点帮助：</p>
<h2 id="RedHat/CentOS/Fedora_系统密码破解">RedHat/CentOS/Fedora 系统密码破解</h2><ol>
<li>在grub选项菜单按E进入编辑模式</li>
<li>编辑kernel 那行最后加上S (或者Single）</li>
<li>按B，启动到single-user mode</li>
<li>进入后执行下列命令<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># mount -t proc proc /proc</span></span><br><span class="line"><span class="preprocessor"># mount -o remount,rw /</span></span><br><span class="line"><span class="preprocessor">#passwd</span></span><br><span class="line"><span class="preprocessor">#sync</span></span><br><span class="line"><span class="preprocessor">#reboot</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>【1】开机画面按e进入<br>【2】进入以下的画面后，选择如下所示的选项，再次按下e按钮； 1 S Single都可以<br>【3】返回到当前页后，按下b按钮起动linux；<br>【4】用passwd命令修改root用户密码；<br>【5】利用shutdown -r now命令重启linux，密码修改完毕。</p>
<h2 id="Debian_linux_系统密码破解">Debian linux 系统密码破解</h2><ol>
<li>在grub选项菜单&#39;Debian GNU/Linux,...(recovery mode)&#39;，按e进入编辑模式</li>
<li>编辑kernel那行最后面的 ro single 改成 rw single init=/bin/bash，按b执行重启</li>
<li>进入后执行下列命令<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@(<span class="attribute">none</span>)<span class="id">#mount</span> -<span class="tag">a</span></span><br><span class="line">root@(<span class="attribute">none</span>)<span class="id">#passwd</span> root</span><br><span class="line">root@(<span class="attribute">none</span>)#reboot</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Freebsd_系统密码破解">Freebsd 系统密码破解</h2><ol>
<li>开机进入引导菜单</li>
<li>选择每项(按4)进入单用户模式</li>
<li>进入之后输入一列命令<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="id">#mount</span> -<span class="tag">a</span></span><br><span class="line">root@<span class="id">#fsck</span> -y</span><br><span class="line">root@#<span class="function"><span class="title">passwd</span><span class="params">(修改密码命令)</span></span></span><br><span class="line">root@#<span class="function"><span class="title">root</span><span class="params">(要破解密码的用户名)</span></span></span><br><span class="line">Enter new unix password:</span><br><span class="line">root@<span class="id">#init</span> <span class="number">6</span> (重启)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Solaris_系统密码破解">Solaris 系统密码破解</h2><ol>
<li>在grub选项菜中选择solaris failasfe 项</li>
<li>系统提示Do you wish to have it mounted read-write on /a ?[y,n,?] 选择y</li>
<li>就进入单用户模式</li>
<li>输入下列命令:<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br><span class="line">root@<span class="title">#init 6</span> <span class="comment">(重启)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="NetBsd_系统密码破解">NetBsd 系统密码破解</h2><ol>
<li><p>开机：当出现提示符号并开始倒数五秒时， 键入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; boot <span class="operator">-s</span> (进入单用户模式命令)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在以下的提示符号中</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter pathname <span class="operator">of</span> <span class="built_in">shell</span> <span class="operator">or</span> <span class="constant">RETURN</span> <span class="keyword">for</span> sh:</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>按下 Enter。</p>
<ol>
<li><p>键入以下指令：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># mount -a</span></span><br><span class="line"><span class="preprocessor"># fsck -y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 passwd 更改 root 的密码。</p>
</li>
<li>使用 exit 指令进入多人模式。<h2 id="SUSE_系统密码破解">SUSE 系统密码破解</h2></li>
<li>重新启动机器，在出现grub引导界面后，在启动linux的选项里加上init=/bin/bash，通过给内核传递init=/bin/bash参数使得OS在运行login程序之前运行bash，出现命令行。</li>
<li>稍等片刻出现(none)#:命令行。</li>
<li>这时输入mount -n / -o remount,rw 表示将根文件系统重新mount为可读写，有了读写权限后就可以通过passwd命令修改密码了。</li>
<li>这时输入passwd命令就可以重置密码了</li>
<li>修改完成后记得用mount -n / -o remount,ro将根文件系统置为原来的状态。</li>
</ol>
<p><a href="http://blog.csdn.net/vagrant2005/article/details/6561637" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="linux下如何进入单人维护模式">linux下如何进入单人维护模式</h1><p>先将系统重新开机，在读秒的时候按下任意键就会出现操作系统的选择画面，仔细看选单底下的说明， 按下『e』就能进入grub的编辑模式了。此時你看到的画面有点像底下这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root (hd0,<span class="number">0</span>)</span><br><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span> ro root=LABEL=/ rhgb quiet</span><br><span class="line">initrd /initrd-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span><span class="class">.img</span></span><br></pre></td></tr></table></figure></p>
<p>此时，请将游标移动到kernel那一行，再按一次『 e 』进入kernel该行的编辑画面中， 然后在出现的画面<br>当中，最后方输入 “single” ：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span>.el5 ro <span class="variable">root=</span><span class="variable">LABEL=</span>/ rhgb quiet single</span><br></pre></td></tr></table></figure></p>
<p>再按下『 Enter 』確定之後，按下 b 就可以开机進入单人维护模式了！<br>在这个模式底下，你会在tty1的地方不需要输入密码即可取得终端机的控制权(而且是使用root的身份喔！)。</p>
<h1 id="各个Linux版本的本地root密码破解方法">各个Linux版本的本地root密码破解方法</h1>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[some Linux tests]]></title>
    <link href="http://tiandechi.com/2015/04/29/some-Linux-tests/"/>
    <id>http://tiandechi.com/2015/04/29/some-Linux-tests/</id>
    <published>2015-04-29T11:35:33.000Z</published>
    <updated>2015-04-29T03:47:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="上部">上部</h1><ol>
<li><p>如何更改linux主机名？<br>编辑配置文件 /etc/sysconfig/network<br>更改HOSTSNAME，保存退出后重启生效；</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="property">@yonglinux</span> ~]<span class="comment"># cat /etc/sysconfig/network</span></span><br><span class="line">NETWORKING=<span class="literal">yes</span></span><br><span class="line">HOSTNAME=yonglinux.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录linux，我们除了使用密码验证，还可以使用哪种方式？简述配置过程。<br>使用密钥加密登录，客户端生成公钥和私钥，客户端保存私钥，公钥复制到远程linux主机，登录时使用密钥加密登录；</p>
<a id="more"></a>
<p>在linux主机执行下面的操作：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /<span class="literal">root</span>/.ssh</span><br><span class="line">chmod  <span class="number">700</span> /<span class="literal">root</span>/.ssh</span><br><span class="line">vi /<span class="literal">root</span>/.ssh/authorized_keys    粘贴复制的公钥，保存退出；</span><br><span class="line">chmod <span class="number">600</span> /<span class="literal">root</span>/.ssh/authorized_keys</span><br><span class="line">vi /etc/<span class="built_in">selinux</span>/config    编辑<span class="built_in">selinux</span>防火墙配置</span><br><span class="line">更改 <span class="constant">S</span>ELINUX=disabled    永久关闭<span class="built_in">selinux</span>；</span><br><span class="line">iptables -<span class="constant">F</span>    清空防火墙规则；</span><br><span class="line">/etc/init.d/iptables save    保存防火墙设置；</span><br><span class="line">客户端使用密钥登录；</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何给grub加密码（明文、密文)，密文加密又分成哪几种？<br>明文加密 vi /etc/grub.conf<br>hiddenmenu下增加一行<br>password=123456<br>保存退出，重启系统进入菜单选择，按p输入密码才可以编辑；<br>密文加密分md5加密和sha加密<br>md5加密命令为：grub-md5-crypt<br>输入密码，生成一串加密后的密码，复制密码<br>vi  /etc/grub.conf<br>password --md5 粘贴密码<br>保存退出，重启系统进入菜单，按p输入密码；<br>sha加密命令：grub-crypt --sha-256<br>输入密码，生成一串密码，复制密码<br>编辑/etc/grub.conf<br>password --encrypted 粘贴密码，<br>保存退出，重启进入系统，按p输入密码；</p>
</li>
<li>如何用yum安装/删除一个软件包？如何查看某个软件包是否已经安装<br>安装：yum install -y tree<br>删除：yum remove -y tree<br>查看：rpm -qa | grep “包名” 或    rpm -q 包名</li>
<li><p>如何查看系统版本？（3个方法）</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> /etc/CentOS-release</span><br><span class="line"><span class="keyword">cat</span> /etc/issue</span><br><span class="line">rpm -<span class="keyword">qa</span> | <span class="keyword">grep</span> release</span><br></pre></td></tr></table></figure>
</li>
<li><p>find 找出 当前目录下的 目录和普通文件？ 找出当前目录下10天没有改变，大小大于4K的普通文件或目录</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./ -<span class="keyword">type</span> <span class="keyword">d</span>  -o -<span class="keyword">type</span> <span class="literal">f</span></span><br><span class="line">find ./ -<span class="keyword">type</span> <span class="keyword">d</span> -o -<span class="keyword">type</span> f -size +4k ! -mtime -10</span><br><span class="line">-</span><br></pre></td></tr></table></figure>
</li>
<li><p>在当前目录下创建一个名字为1的目录 的命令？  创建级联目录 ./2/3/的命令？ 一条命令创建级联目录 ./1/2/3和./1/2/4?</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./<span class="number">1</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./<span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./<span class="number">1</span>/<span class="number">2</span>/&#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cp一个目录中的文件需要什么权限，mv呢？touch呢？rm呢？<br>cp需要有目录的x权限，mv需要wx权限，touch需要wx权限，rm需要有wx权限；</p>
</li>
<li><p>用cat如何向文件里重定向字符串<br>第一种方法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user1<span class="variable">@localhost</span> tmp]<span class="variable">$ </span>cat <span class="prompt">&gt;&gt;</span><span class="number">1</span>.txt</span><br><span class="line"><span class="number">000000000000</span></span><br><span class="line"><span class="number">111111111111</span></span><br><span class="line"><span class="number">222222222222</span></span><br><span class="line">最后按ctrl + d</span><br></pre></td></tr></table></figure>
<p>第二种方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt;<span class="number">1</span>.txt&lt;</span><br><span class="line">&gt; <span class="number">000000000000</span></span><br><span class="line">&gt; qqqqqqqqqqqqq</span><br><span class="line">&gt;<span class="function"><span class="title">EOF</span><span class="params">(这个结束)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>建立一个公共目录/opt/public,要求每个用户都可以创建文件和目录，但只能自己本人和root可以删除；</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/opt/</span><span class="keyword">public</span></span><br><span class="line">chmod <span class="number">1777</span> <span class="regexp">/opt/</span><span class="keyword">public</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="下部">下部</h1><ol>
<li><p>如何查看当前用户的家目录是什么?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果设置 umask 为 001 , 那么用户默认创建的目录和文件的权限是什么样子的？<br>创建的目录为766，文件为666</p>
</li>
<li><p>出于安全考虑，如何实现让别人ping不通你的在线的服务器。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎样防止他人在服务器前通过按下 ctrl+alt+del 强行重启系统（提示，仔细看/etc/inittab）</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/init/control-alt-<span class="keyword">delete</span>.conf</span><br><span class="line"><span class="keyword">exec</span> /sbin/<span class="keyword">shutdown</span> -r now <span class="string">"Control-Alt-Delete pressed"</span>    这一项<span class="comment">#号注释掉，保存退出；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当在对服务器进行大负荷操作的时候，你不希望现在有普通用户登录上来，你该怎么做？不能剪网线。<br>touch /etc/nologin<br>创建一个nologin文件，此文件为特殊文件，创建之后所有普通用户不能登录；系统维护结束后删除此文件，用户可以恢复登录；只限于shell登录用户，本身shell为/sbin/nologin 的用户本身就无法登录shell，不受影响；</p>
</li>
<li>你新建了一批用户，出于安全考虑，要求这些用户在第一次登录的时候 就必须要更改密码，怎么实现？<br>修改/etc/shadow 第三列，新建用户的值更改为0.</li>
<li><p>如何把一个目录下的所有文件(不含目录)权限改为644？</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./ -<span class="built_in">type</span> f | xargs chmod <span class="number">644</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请实现下面这个需求：只允许使用普通账户登陆，而普通账户登录后，可以不输入密码就能sudo切换到root账户，root是不允许远程登录的。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sudoers</span><br><span class="line">添加一行<span class="keyword">user</span>    <span class="constant">A</span>LL=(<span class="literal">root</span>)    <span class="constant">N</span>OPASSWD: /bin/su</span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="constant">Permit</span>RootLogin 设置为no，禁止<span class="literal">root</span>远程登录；</span><br><span class="line"><span class="keyword">service</span> sshd <span class="literal">restart</span>    重启sshd服务生效；</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何使文件只能写不能删除？ 如何使文件不能被删除、重命名、设定链接接、写入、新增数据？<br>chattr +a    只能写不能删除<br>chattr +i    不能删除，重命名，写入新增数据；</p>
</li>
<li>用ls 查看目录或者文件时，第二列的数值表示什么意思？如果一个目录的这列的值为3，那么这个3是如何得到的？<br>第二列数值表示有几个文件使用相同的inode；<br>如果一个目录的这列为3，我们可以通过使用 ls -al dir/ |grep &#39;^d&#39;|wc -l 这条命令得到；<br><a href="http://www.linuxidc.com/Linux/2015-04/116337.htm" target="_blank" rel="external">来源</a></li>
</ol>
<h1 id="面试题">面试题</h1><ol>
<li>如何查看当前的Linux服务器的运行级别？<br>答: ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别。</li>
<li>如何查看Linux的默认网关？<br>答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。</li>
<li>如何在Linux上重建初始化内存盘镜像文件？<br>答: 在CentOS 5.X / RHEL 5.X中，可以用mkinitrd命令来创建初始化内存盘文件，举例如下：<h1 id="mkinitrd_-f_-v_/boot/initrd-$(uname_-r)-img_$(uname_-r)">mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r)</h1>如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 ‘uname -r’ 。<br>在CentOS 6.X / RHEL 6.X中，则用dracut命令来创建初始化内存盘文件，举例如下：<h1 id="dracut_-f">dracut -f</h1>以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令：<h1 id="dracut_-f_initramfs-2-x-xx-xx-el6-x86_64-img_2-x-xx-xx-el6-x86_64">dracut -f initramfs-2.x.xx-xx.el6.x86_64.img 2.x.xx-xx.el6.x86_64</h1></li>
<li>cpio命令是什么？<br>答: cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。</li>
<li>patch命令是什么？如何使用？<br>答: 顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。举个例子，Linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，然后接收者用patch命令将改动写进原始的源代码里。<br>创建一个diff文件给patch使用，<h1 id="diff_-Naur_old_file_new_file_&gt;_diff_file">diff -Naur old_file new_file &gt; diff_file</h1>旧文件和新文件要么都是单个的文件要么都是包含文件的目录，-r参数支持目录树递归。<br>一旦diff文件创建好，我们就能在旧的文件上打上补丁，把它变成新文件：<h1 id="patch_&lt;_diff_file">patch &lt; diff_file</h1></li>
<li>aspell有什么用 ?<br>答: 顾名思义，aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品 ，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。</li>
<li>如何从命令行查看域SPF记录？<br>答: 我们可以用dig命令来查看域SPF记录。举例如下<br>linuxtechi@localhost:~$ dig -t TXT google.com</li>
<li>如何识别Linux系统中指定文件(/etc/fstab)的关联包？<br>答:<h1 id="rpm_-qf_/etc/fstab">rpm -qf /etc/fstab</h1>以上命令能列出提供“/etc/fstab”这个文件的包。</li>
<li>哪条命令用来查看bond0的状态？<br>答:<br>cat /proc/net/bonding/bond0</li>
<li>Linux系统中的/proc文件系统有什么用？<br>答: /proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。</li>
<li>如何在/usr目录下找出大小超过10MB的文件？<br>答:<h1 id="find_/usr_-size_+10M">find /usr -size +10M</h1></li>
<li>如何在/home目录下找出120天之前被修改过的文件？<br>答:<h1 id="find_/home_-mtime_+120">find /home -mtime +120</h1></li>
<li>如何在/var目录下找出90天之内未被访问过的文件？<br>答:<h1 id="find_/var_!_-atime_-90">find /var ! -atime -90</h1></li>
<li>在整个目录树下查找文件“core”，如发现则无需提示直接删除它们。<br>答:<h1 id="find_/_-name_core_-exec_rm_{}_\;">find / -name core -exec rm {} \;</h1></li>
<li>strings命令有什么作用？<br>答: strings命令用来提取和显示非文本文件中的文本字符串。（LCTT 译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处）</li>
<li>tee 过滤器有什么作用 ?<br>答: tee 过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。<br>linuxtechi@localhost:~$ ll /etc | nl | tee /tmp/ll.out<br>在以上例子中，从ll输出可以捕获到 /tmp/ll.out 文件中，并且同样在屏幕上显示了出来。</li>
<li>export PS1 = ”$LOGNAME@hostname:\$PWD: 这条命令是在做什么？<br>答: 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。</li>
<li>ll | awk ‘{print $3,”owns”,$9}’ 这条命令是在做什么？<br>答: 这条ll命令会显示这些文件的文件名和它们的拥有者。</li>
<li>:Linux中的at命令有什么用？<br>答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。</li>
<li>linux中lspci命令的作用是什么？<br>答: lspci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性。</li>
</ol>
<p><a href="http://www.linuxidc.com/Linux/2015-02/112637.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="上部">上部</h1><ol>
<li><p>如何更改linux主机名？<br>编辑配置文件 /etc/sysconfig/network<br>更改HOSTSNAME，保存退出后重启生效；</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="property">@yonglinux</span> ~]<span class="comment"># cat /etc/sysconfig/network</span></span><br><span class="line">NETWORKING=<span class="literal">yes</span></span><br><span class="line">HOSTNAME=yonglinux.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录linux，我们除了使用密码验证，还可以使用哪种方式？简述配置过程。<br>使用密钥加密登录，客户端生成公钥和私钥，客户端保存私钥，公钥复制到远程linux主机，登录时使用密钥加密登录；</p>]]>
    
    </summary>
    
      <category term="tests" scheme="http://tiandechi.com/tags/tests/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The advantages of Linux compile source code for installing package]]></title>
    <link href="http://tiandechi.com/2015/04/21/The-advantages-of-Linux-compile-source-code-for-installing-package/"/>
    <id>http://tiandechi.com/2015/04/21/The-advantages-of-Linux-compile-source-code-for-installing-package/</id>
    <published>2015-04-21T11:01:33.000Z</published>
    <updated>2015-04-21T05:00:54.000Z</updated>
    <content type="html"><![CDATA[<p>很多人放着最新的源码不用，等着有人帮他做出rpm,deb,才能安装。我说你为什么不用源码编译，这样版本比rpm高的多，有很多新功能，而没有烦人的依赖关系。可是他说：“要是我用源码编译安装，卸载的时候就不方便了，会留下很多垃圾。”<br><a id="more"></a><br>为什么程序还没有安装你就想到卸载？难道你不知道这个程序是用来做什么的？你应该改变到处找程序来试用的作法，而应该先了解一下到底那些程序有同样的功能，听听别人的意见，看看它们各有什么长处和短处，然后挑一个最适合你的程序来用。</p>
<p>从源码编译安装程序，不但比你装rpm更适合自己的机器设置，而且它们一般会装到/usr/local目录，这样你以后如果换硬盘重装系统，也可以把以前/usr/local下的程序原封不动拷贝过去用。我的/usr/local下有2G之多的程序，你想要是我有一台新机器要重新安装，然后配置，得花费多少时间？实际上我曾经通过网络把它们传到一台新机器上，然后就出去吃晚饭，回来时我就得到了另一台一摸一样的Linux机器。</p>
<p>确实要卸载makeinstall的程序怎么办呢？答案是直接删掉。别以为直接删掉程序会留下垃圾，引起“系统不稳定”。(btw:这是谁教你的啊？呵呵。)makeinstall无非就是把可执行程序放在/usr/local/bin,把某些函数库放在/usr/local/lib，把数据文件放在 /usr/local/share下一个它自己的目录，你把这些东西都删掉就行了，不会留下垃圾，即使真的留下一点文件没有删掉也占不了多少空间，更不可能引起系统不稳定。UNIX就是这么简单</p>
<p>但是有几个程序不建议从源码安装，它们是Mozilla,OpenOffice,...它们编译时会占用你几个G的空间和好几个小时的时间，这种花费我觉得是不值得的，因为你不能从编译得到更多好处，不如直接安装编译好的版本。</p>
<p><a href="http://blog.163.com/qiantu1986@126/blog/static/3592266920114172382031/" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很多人放着最新的源码不用，等着有人帮他做出rpm,deb,才能安装。我说你为什么不用源码编译，这样版本比rpm高的多，有很多新功能，而没有烦人的依赖关系。可是他说：“要是我用源码编译安装，卸载的时候就不方便了，会留下很多垃圾。”<br>]]>
    
    </summary>
    
      <category term="advantage" scheme="http://tiandechi.com/tags/advantage/"/>
    
      <category term="compile" scheme="http://tiandechi.com/tags/compile/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[the physical structure and IO process of the disk]]></title>
    <link href="http://tiandechi.com/2015/04/21/the-physical-structure-and-IO-process-of-the-disk/"/>
    <id>http://tiandechi.com/2015/04/21/the-physical-structure-and-IO-process-of-the-disk/</id>
    <published>2015-04-21T10:58:12.000Z</published>
    <updated>2015-04-21T04:59:56.000Z</updated>
    <content type="html"><![CDATA[<p>对于管理磁盘，分磁盘面、磁头、磁道、柱面和扇区。</p>
<pre><code>磁盘面：磁盘是由一叠磁盘面组成，见下左图。
磁头(Heads)：每个磁头对应一个磁盘面，负责该磁盘面上的数据的读写。
磁道(Track)：每个盘面会围绕圆心划分出多个同心圆圈，每个圆圈叫做一个磁道。
柱面(Cylinders)：所有盘片上的同一位置的磁道组成的立体叫做一个柱面。
扇区(Sector)：以磁道为单位管理磁盘仍然太大，所以计算机前辈们又把每个磁道划分出了多个扇区，见下图
![<span class="link_label">HDD physical structure</span>](<span class="link_url">http://ww4.sinaimg.cn/mw690/6e8d8f65gw1erbso6izmoj20ib08cq4d.jpg</span>)
</code></pre><a id="more"></a>
<p>Linux上可以通过fdisk命令，来查看当前系统使用的磁盘的这些物理信息。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="annotation">@dbserver</span> ~]# fdisk -l</span><br><span class="line">Disk <span class="regexp">/dev/</span><span class="string">sda:</span> <span class="number">1199.6</span> GB, <span class="number">1199638052864</span> bytes</span><br><span class="line"><span class="number">255</span> heads, <span class="number">63</span> sectors/track, <span class="number">145847</span> cylinders</span><br><span class="line">Units = cylinders of <span class="number">16065</span> * <span class="number">512</span> = <span class="number">8225280</span> bytes</span><br><span class="line">Sector size (logical<span class="regexp">/physical): 512 bytes /</span> <span class="number">512</span> bytes</span><br><span class="line">I<span class="regexp">/O size (minimum/</span>optimal): <span class="number">512</span> bytes / <span class="number">512</span> bytes</span><br><span class="line">Disk <span class="string">identifier:</span> <span class="number">0x54ab02ca</span></span><br><span class="line">Device Boot      Start        End      Blocks  Id  System</span><br><span class="line"><span class="regexp">/dev/</span>sda1              <span class="number">1</span>          <span class="number">5</span>      <span class="number">40131</span>  de  Dell Utility</span><br><span class="line">Partition <span class="number">1</span> does not end on cylinder boundary.</span><br><span class="line"><span class="regexp">/dev/</span>sda2  *          <span class="number">6</span>        <span class="number">267</span>    <span class="number">2097152</span>    c  W95 FAT32 (LBA)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>可以看出我的磁盘有255个heads，也就是说共有255个盘面。145847 个cylinders，也就是说每个盘面上都有145847 个磁道， 63sectors/track说的是每个磁道上共有63个扇区。命令结果也给出了Sector size的值是512bytes。那我们动笔算一下该磁盘的大小。<br>255盘面  <em> 145847 柱面 </em> 63扇区 * 每个扇区512bytes =1199632412160 byte=1117.25GB<br>结果是1117.25GB,和磁盘的总大小相符。<br>在如上图可以发现一个错误（标红），是即/dev/sda1的start位置从第 1 扇区个删除开始，如果将第0至62个扇区,即第一磁道（cylinders）单独留给磁盘MBR并从第64个扇区，即第二个磁道（cylinders）开始分区，将会对文件系统的性能会带来很大的提升。</p>
<p>接下来让我们在了解一下磁盘IO时的过程。</p>
<ol>
<li>首先是磁头径向移动来寻找数据所在的磁道。这部分时间叫寻道时间。</li>
<li>找到目标磁道后通过盘面旋转，将目标扇区移动到磁头的正下方。</li>
<li>向目标扇区读取或者写入数据。到此为止，一次磁盘IO完成。</li>
</ol>
<p>故：单次磁盘IO时间 = 寻道时间 + 旋转延迟 + 存取时间。<br>对于旋转延时，现在主流服务器上经常使用的是1W转/分钟的磁盘，每旋转一周所需的时间为60*1000/10000=6ms，故其旋转延迟为（0-6ms）。对于存取时间，一般耗时较短，为零点几ms。对于寻道时间，现代磁盘大概在3-15ms，其中寻道时间大小主要受磁头当前所在位置和目标磁道所在位置相对距离的影响。</p>
<pre><code>操作系统通过按磁道对应的柱面划分分区，来降低磁盘IO所花费的的寻道时间 ，进而提高磁盘的读写性能。
</code></pre><hr>
<p>实际上，上面这段话还是存在问题的，分区对性能的提高几乎为0，我在 V2EX 有讨论： <a href="http://www.v2ex.com/t/184874" target="_blank" rel="external">分区能提高硬盘的读写性能？</a></p>
<p><a href="http://www.linuxidc.com/Linux/2015-04/116419.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于管理磁盘，分磁盘面、磁头、磁道、柱面和扇区。</p>
<pre><code>磁盘面：磁盘是由一叠磁盘面组成，见下左图。
磁头(Heads)：每个磁头对应一个磁盘面，负责该磁盘面上的数据的读写。
磁道(Track)：每个盘面会围绕圆心划分出多个同心圆圈，每个圆圈叫做一个磁道。
柱面(Cylinders)：所有盘片上的同一位置的磁道组成的立体叫做一个柱面。
扇区(Sector)：以磁道为单位管理磁盘仍然太大，所以计算机前辈们又把每个磁道划分出了多个扇区，见下图
![<span class="link_label">HDD physical structure</span>](<span class="link_url">http://ww4.sinaimg.cn/mw690/6e8d8f65gw1erbso6izmoj20ib08cq4d.jpg</span>)
</code></pre>]]>
    
    </summary>
    
      <category term="Disk" scheme="http://tiandechi.com/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VSFTP server configure]]></title>
    <link href="http://tiandechi.com/2015/04/19/VSFTP-server-configure/"/>
    <id>http://tiandechi.com/2015/04/19/VSFTP-server-configure/</id>
    <published>2015-04-19T08:19:25.000Z</published>
    <updated>2015-04-19T01:55:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Linux_FTP服务器分类：">Linux FTP服务器分类：</h1><ol>
<li>wu-ftp</li>
<li>proftp=profession ftp</li>
<li>vsftp=very security ftp</li>
</ol>
<p>配置文件：<br>    /etc/vsftpd/vsftpd.conf   //主配置文件</p>
<pre><code>/etc/vsftpd<span class="class">.ftpusers</span>      <span class="comment">//被禁止登录FTP的用户文件</span>

/etc/vsftpd<span class="class">.user_list</span>     <span class="comment">//允许登录FTP的用户文件</span>
</code></pre><h1 id="访问方式">访问方式</h1><ol>
<li>匿名登录</li>
<li>帐号登录</li>
</ol>
<a id="more"></a>
<h1 id="启动FTP服务器：">启动FTP服务器：</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#service vsftpd restart</span><br></pre></td></tr></table></figure>
<h1 id="配置vsftp服务器">配置vsftp服务器</h1><ol>
<li><p>vsftpd.conf各项参数说明：</p>
<pre><code><span class="comment">#vi /etc/vsftpd/vsftpd.conf</span>

<span class="variable">&lt;1&gt;</span>第7行： 控制匿名登录

            anonymous_enable=YES 改成NO

<span class="variable">&lt;2&gt;</span>第10行：允许本地帐号登录

<span class="variable">&lt;3&gt;</span>第13行：控制可写权限

<span class="variable">&lt;4&gt;</span>第17行：控制本地文件的权限掩码

<span class="variable">&lt;5&gt;</span>第22行：控制是否允许匿名上传(与26行同时开启或关闭)

<span class="variable">&lt;6&gt;</span>第26行：控制是否允许匿名写及创建目录的权限

<span class="variable">&lt;7&gt;</span>第33行：控制上传或下载的日志记录

<span class="variable">&lt;8&gt;</span>第46行：控制日志的保存路径

<span class="variable">&lt;9&gt;</span>第52行：设置指令超时的时间，默认为600秒

<span class="variable">&lt;10&gt;</span>第55行：设置数据连接的超时时间，默认为120秒

<span class="variable">&lt;11&gt;</span>第91行：控制登录FTP的用户是否被限制在家目录下;(必须与93行同时开启或关闭)

            chroot_list_enable=YES

<span class="variable">&lt;12&gt;</span>第93行：登录FTP后被限制在家目录下的用户列表文件

            chroot_list_file=/etc/vsftpd.chroot_list

            在/etc目录下新建一个vsftpd.chroot_list文件，内容加入要限制用户的用户名

            没加入限制用户可以访问其目录

<span class="variable">&lt;13&gt;</span>第99行：控制登录FTP后是否允许ls命令

<span class="variable">&lt;14&gt;</span>第102行:启用/etc/vsftpd.user_list文件
</code></pre></li>
<li><p>配置匿名登录</p>
<pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

第<span class="number">7</span>行，设置为： (默认值)

anonymous_enable=YES

启动vsftpd服务器：

<span class="id">#service</span> vsftpd restart

<span class="id">#service</span> iptables stop

匿名登录的默认目录：

/var/ftp/pub

打开匿名上传和写权限：

<span class="id">#vi</span> /etc/vsftpd/vsftp<span class="class">.conf</span>

激活第<span class="number">22</span>行

激活第<span class="number">26</span>行

打开默认共享目录的权限

<span class="id">#chmod</span> <span class="number">777</span> /var/ftp/pub

备注：匿名可以上传下载，但不能删除；
</code></pre></li>
<li><p>本地帐号登录</p>
<pre><code>&lt;<span class="number">1</span>&gt;禁用匿名登入

修改配置文件

<span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

禁用所有匿名控制行,如：

   禁用第<span class="number">7</span>行，第<span class="number">22</span>行，第<span class="number">26</span>行；

&lt;<span class="number">2</span>&gt;开放那些用户可以登入和那些用户拒绝登入

<span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

    在<span class="number">102</span>行后，插入如下：

    userlist_deny=NO

       (备注：设置/etc/vsftpd.user_list文件中的用户可登录FTP)

    保存退出

   如果是#userlist_deny=NO 注释掉，则默认全部用户可以登入FTP,当要限某用户不能登入：

    把用户名加入这个文件当中/etc/vsftpd.ftpusers，则这个用户名拒绝登入FTP

     创建用户并加入到相应的控制文件中

      <span class="id">#useradd</span> us1

<span class="id">#useradd</span> us2

      <span class="id">#passwd</span> us1

      <span class="id">#passwd</span> us2

     允许登录到FTP的用户：

      <span class="id">#echo</span> us1&gt;&gt;/etc/vsftpd<span class="class">.user_list</span>

      <span class="id">#echo</span> us2&gt;&gt;/etc/vsftpd<span class="class">.user_list</span>   
</code></pre></li>
</ol>
<h1 id="启动FTP服务器：-1">启动FTP服务器：</h1><pre><code><span class="id">#service</span> vsftpd restart

备注：帐号登录FTP，默认是登录在家目录下；

禁止登录到FTP的用户：

<span class="id">#echo</span> us3&gt;&gt;/etc/vsftpd.ftpusers
</code></pre><h1 id="将登录后的用户限制在本地家目录下：">将登录后的用户限制在本地家目录下：</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

激活第<span class="number">91</span>行及第<span class="number">93</span>行

   chroot_list_enable=YES

   chroot_list_file=/etc/vsftpd<span class="class">.chroot_list</span>


新建受限用户的列表文件并加入受限用户名

<span class="id">#vi</span> /etc/vsftpd<span class="class">.chroot_list</span>

  us2

保存退出

<span class="id">#service</span> vsftpd restart
</code></pre><h1 id="限制匿名上传的速度：">限制匿名上传的速度：</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

:$

anon_max_rate=<span class="number">5000</span> <span class="comment">//默认以字节为单位 5000表示5K速度</span>
</code></pre><h1 id="限制本地帐号的上传速度：">限制本地帐号的上传速度：</h1><pre><code>local_max_rate=<span class="number">5000</span> <span class="comment">//以(字节/秒)为单位</span>
</code></pre><h1 id="针对不同的使用者限制不同的速度(这个速度优先限制所有用户的速度）:">针对不同的使用者限制不同的速度(这个速度优先限制所有用户的速度）:</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>   增加下面一行

user_config_dir=/etc/vsftpd/userconf

<span class="id">#mkdir</span> /etc/vsftpd/userconf   创建一个目录

<span class="id">#vi</span> /etc/vsftpd/userconf/user1   （user1是要限制速度的用户名)

local_max_rate=<span class="number">25000</span>
</code></pre><h1 id="定制欢迎信息：">定制欢迎信息：</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

激活<span class="number">80</span>行

ftpd_banner=Welcome to Huayu FTP service.
</code></pre><h1 id="限制服务器连接数和同IP连接数">限制服务器连接数和同IP连接数</h1><ol>
<li>max_clients<br>可使用这个参数定义最大的总联机数。超过这个数目将会拒绝联机，0 表示不限。默认值为0。</li>
<li>max_per_ip<br>使用这个参数定义每个ip address 所可以联机的数目。超过这个数目将会拒绝联机，0 表示不限。默认值为0</li>
</ol>
<h1 id="虚拟FTP用户设置">虚拟FTP用户设置</h1><ol>
<li><p>建立虚拟用户口令库文件</p>
<pre><code><span class="id">#vi</span> /etc/vsftpd/logins<span class="class">.txt</span>

vuser1

<span class="number">123</span>

vuser2

<span class="number">321</span>

:wq

口令库文件中奇数行设置用户名，偶数行设置口令
</code></pre></li>
<li>生成vsftpd的认证文件<pre><code><span class="id">#db_load</span> -T -t hash -f /etc/vsftpd/logins<span class="class">.txt</span> /etc/vsftpd/vsftpd_login<span class="class">.db</span> ##生成认证文件
</code></pre></li>
<li>设置认证文件只对root用户可读可写<pre><code><span class="preprocessor"># chmod 600 /etc/vsftpd/vsftpd_login.db</span>
</code></pre></li>
<li>建立虚拟用户所需的PAM配置文件，手工建立vsftpd.vu文件<pre><code># cat <span class="regexp">/etc/</span>pam.d/vsftpd.vu
auth required <span class="regexp">/lib/</span>security<span class="regexp">/pam_userdb.so db=/</span>etc<span class="regexp">/vsftpd/</span>vsftpd_login
account required <span class="regexp">/lib/</span>security<span class="regexp">/pam_userdb.so db=/</span>etc<span class="regexp">/vsftpd/</span>vsftpd_login
</code></pre></li>
<li>建立所有FTP虚拟用户帐号使用的系统用户帐号，并设置该帐号宿主目录的权限<pre><code><span class="preprocessor"># useradd -d /home -s /sbin/nologin /ftpsite virtual</span>
<span class="preprocessor"># chmod 700 /home/ftpsite</span>
</code></pre></li>
<li><p>设置vsftpd.conf配置文件</p>
<pre><code><span class="comment">#vi /etc/vsftpd/vsftpd.conf</span>

在配置文件中添加虚拟用户的配置内容

<span class="constant">guest_enable</span>=YES

<span class="constant">guest_username</span>=virtual

<span class="constant">pam_service_name</span>=vsftpd.vu（要和刚才建的PAM文件对应）

<span class="constant">user_config_dir</span>=/etc/vsftpd/user_config_dir （指定每个虚拟用户账号配置目录，）
<span class="constant">local_root</span>=/www （这行没有，虚拟用户登入到/ftpsite）
</code></pre></li>
<li><p>配置虚拟用户名的设置</p>
<pre><code><span class="comment">#mkdir -p /etc/vsftpd/user_config_dir （主配置文件对应）</span>
<span class="comment">#mkdir -p /www/vuser1    （创建虚拟用主目录）</span>
<span class="comment">#chmod -R 777 /www/vuser1 （设定权限）</span>

<span class="comment">#touch /etc/vsftpd/user_config_dir/vuser1 (为vuser1权限配置文件)</span>
<span class="comment">#echo "anon_world_readable_only=NO</span>
write_<span class="built_in">enable</span>=YES
anon_upload_<span class="built_in">enable</span>=YES
anon_other_write_<span class="built_in">enable</span>=YES
<span class="built_in">local</span>_root=/www/feixiang
anon_mkdir_write_<span class="built_in">enable</span>=YES<span class="string">" &gt;/etc/vsftpd/user_config_dir/vuser1</span>
</code></pre></li>
<li><p>重新启动vsftpd服务程序</p>
<pre><code><span class="preprocessor"># service vsftpd restart</span>

现在就应该可以用虚拟帐号登陆了.
</code></pre></li>
</ol>
<p><a href="http://www.cnblogs.com/JemBai/archive/2009/02/05/1384413.html" target="_blank" rel="external">Linux VSFTP服务器详细配置</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Linux_FTP服务器分类：">Linux FTP服务器分类：</h1><ol>
<li>wu-ftp</li>
<li>proftp=profession ftp</li>
<li>vsftp=very security ftp</li>
</ol>
<p>配置文件：<br>    /etc/vsftpd/vsftpd.conf   //主配置文件</p>
<pre><code>/etc/vsftpd<span class="class">.ftpusers</span>      <span class="comment">//被禁止登录FTP的用户文件</span>

/etc/vsftpd<span class="class">.user_list</span>     <span class="comment">//允许登录FTP的用户文件</span>
</code></pre><h1 id="访问方式">访问方式</h1><ol>
<li>匿名登录</li>
<li>帐号登录</li>
</ol>]]>
    
    </summary>
    
      <category term="VSFTP" scheme="http://tiandechi.com/tags/VSFTP/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
</feed>