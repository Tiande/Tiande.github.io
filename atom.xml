<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天德池]]></title>
  <subtitle><![CDATA[这里不是洗澡的地方]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://tiandechi.com/"/>
  <updated>2015-05-10T05:28:54.009Z</updated>
  <id>http://tiandechi.com/</id>
  
  <author>
    <name><![CDATA[钢仔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux dd命令制作U盘系统启动盘]]></title>
    <link href="http://tiandechi.com/2015/05/10/Linux-dd%E5%91%BD%E4%BB%A4%E5%88%B6%E4%BD%9CU%E7%9B%98%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    <id>http://tiandechi.com/2015/05/10/Linux-dd命令制作U盘系统启动盘/</id>
    <published>2015-05-10T05:26:41.000Z</published>
    <updated>2015-05-10T05:28:54.009Z</updated>
    <content type="html"><![CDATA[<p>作U盘系统启动盘，Ubuntu下有个图形界面工具Startup Disk Creator，简单易用，但是缺点就是只能制作Ubuntu的启动盘，别的系统不支持。那么我想在Ubuntu下作Fedora的系统启动盘要怎么办呢？不要紧，有dd命令呢！</p>
<p>dd命令是用来拷贝文件的命令，它可以自动转换成对应的格式。在玩树莓派的时候，我们也是用dd命令烧写系统的，还记得吧？<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="tag">dd</span> bs=<span class="number">4</span>M <span class="keyword">if</span>=~/raspberrypi/<span class="number">2014</span>-<span class="number">09</span>-<span class="number">09</span>-wheezy-raspbian<span class="class">.img</span> of=/dev/sdb &amp;&amp; sync</span><br></pre></td></tr></table></figure></p>
<p>dd命令简单用法就是这样，那么我们还可以用它烧写光盘和作其他系统的启动U盘。<br><a id="more"></a><br>在玩树莓派时烧写的文件是img格式的系统镜像，而我们要制作Fedora等Linux发行版通常是iso格式的文件，不要紧，formatting的问题就交给dd命令吧。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="tag">dd</span> --help</span><br><span class="line">Usage: <span class="tag">dd</span> [OPERAND]...</span><br><span class="line">or: <span class="tag">dd</span> OPTION</span><br><span class="line">Copy <span class="tag">a</span> file, converting and formatting according to the operands.</span><br></pre></td></tr></table></figure></p>
<h1 id="过程都是类似的，首先要umount自己的U盘：">过程都是类似的，首先要umount自己的U盘：</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line"><span class="regexp">/dev/</span>sdb1 <span class="number">3.8</span>G <span class="number">880</span>K <span class="number">3.8</span>G <span class="number">1</span>% <span class="regexp">/media/</span>linc/<span class="number">87</span>CD-<span class="number">7</span>F86</span><br><span class="line"></span><br><span class="line">$ umount <span class="regexp">/dev/</span>sdb1</span><br></pre></td></tr></table></figure>
<h1 id="然后就是dd命令烧写：">然后就是dd命令烧写：</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="tag">dd</span> bs=<span class="number">4</span>M <span class="keyword">if</span>=~/linux_images/Fedora-Live-Workstation-i686-<span class="number">21</span>-<span class="number">5</span><span class="class">.iso</span> of=/dev/sdb &amp;&amp; sync</span><br><span class="line">[sudo] password <span class="keyword">for</span> linc:</span><br><span class="line"><span class="number">318</span>+<span class="number">1</span> records <span class="keyword">in</span></span><br><span class="line"><span class="number">318</span>+<span class="number">1</span> records out</span><br><span class="line"><span class="number">1336934400</span> bytes (<span class="number">1.3</span> GB) copied, <span class="number">171.331</span> s, <span class="number">7.8</span> MB/s</span><br></pre></td></tr></table></figure>
<p><strong>注意，dd命令中的目标是sdb，没有标号。</strong></p>
<p><a href="http://www.linuxidc.com/Linux/2015-02/113585.htm" target="_blank" rel="external">source</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作U盘系统启动盘，Ubuntu下有个图形界面工具Startup Disk Creator，简单易用，但是缺点就是只能制作Ubuntu的启动盘，别的系统不支持。那么我想在Ubuntu下作Fedora的系统启动盘要怎么办呢？不要紧，有dd命令呢！</p>
<p>dd命令是用来拷贝文件的命令，它可以自动转换成对应的格式。在玩树莓派的时候，我们也是用dd命令烧写系统的，还记得吧？<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="tag">dd</span> bs=<span class="number">4</span>M <span class="keyword">if</span>=~/raspberrypi/<span class="number">2014</span>-<span class="number">09</span>-<span class="number">09</span>-wheezy-raspbian<span class="class">.img</span> of=/dev/sdb &amp;&amp; sync</span><br></pre></td></tr></table></figure></p>
<p>dd命令简单用法就是这样，那么我们还可以用它烧写光盘和作其他系统的启动U盘。<br>]]>
    
    </summary>
    
      <category term="dd" scheme="http://tiandechi.com/tags/dd/"/>
    
      <category term="启动盘" scheme="http://tiandechi.com/tags/%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[查看Debian的版本信息]]></title>
    <link href="http://tiandechi.com/2015/05/10/%E6%9F%A5%E7%9C%8BDebian%E7%9A%84%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
    <id>http://tiandechi.com/2015/05/10/查看Debian的版本信息/</id>
    <published>2015-05-10T05:06:47.000Z</published>
    <updated>2015-05-10T05:08:04.354Z</updated>
    <content type="html"><![CDATA[<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor <span class="string">ID:</span> Debian</span><br><span class="line"><span class="string">Description:</span> Debian GNU/Linux testing (squeeze)</span><br><span class="line"><span class="string">Release:</span> testing</span><br><span class="line"><span class="string">Codename:</span> squeeze</span><br><span class="line"></span><br><span class="line">$ cat <span class="regexp">/etc/</span>debian_version</span><br><span class="line">squeeze/sid</span><br></pre></td></tr></table></figure>
<p>/usr/share/doc/base-files/FAQ:</p>
<p>Q. Ok, but how do I know which distribution I&#39;m running?</p>
<p>A. If you are running testing or unstable, then /etc/debian_version is<br>not a reliable way to know that anymore. Looking at the contents of<br>your /etc/apt/sources.list file is probably a much better way.</p>
<p>其他相关的或有趣的包还有：<br><a id="more"></a><br>base-files</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$ </span>linuxinfo<span class="variable">$ </span>linuxlogo</span><br></pre></td></tr></table></figure>
<p>查看内核版本：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cat /<span class="keyword">proc</span>/version</span><br><span class="line"></span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/lbsx/archive/2010/12/29/1920989.html" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor <span class="string">ID:</span> Debian</span><br><span class="line"><span class="string">Description:</span> Debian GNU/Linux testing (squeeze)</span><br><span class="line"><span class="string">Release:</span> testing</span><br><span class="line"><span class="string">Codename:</span> squeeze</span><br><span class="line"></span><br><span class="line">$ cat <span class="regexp">/etc/</span>debian_version</span><br><span class="line">squeeze/sid</span><br></pre></td></tr></table></figure>
<p>/usr/share/doc/base-files/FAQ:</p>
<p>Q. Ok, but how do I know which distribution I&#39;m running?</p>
<p>A. If you are running testing or unstable, then /etc/debian_version is<br>not a reliable way to know that anymore. Looking at the contents of<br>your /etc/apt/sources.list file is probably a much better way.</p>
<p>其他相关的或有趣的包还有：<br>]]>
    
    </summary>
    
      <category term="Debian" scheme="http://tiandechi.com/tags/Debian/"/>
    
      <category term="version" scheme="http://tiandechi.com/tags/version/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to disable Network Manager on Linux]]></title>
    <link href="http://tiandechi.com/2015/05/10/How-to-disable-Network-Manager-on-Linux/"/>
    <id>http://tiandechi.com/2015/05/10/How-to-disable-Network-Manager-on-Linux/</id>
    <published>2015-05-10T05:03:43.000Z</published>
    <updated>2015-05-10T05:12:30.956Z</updated>
    <content type="html"><![CDATA[<p>Network Manager is a feature-rich network configuration service which is used by default in most Linux desktop environments nowadays. It provides automatic configuration of (wired/wireless) network interfaces, as well as VPN, mobile broadband and even Bluetooth connections. Network Manager is smart enough to automatically switch to the best (or the most recent) connection network, and can inform other applications of up-to-date network events via D-Bus API.</p>
<p>While Network Manager comes with various sophisticated features, you might just prefer the old plain network service. There could be several reasons to do so. For one, you may wish to have more control over network management, instead of relying on purely automatic configuration and switch-over, which may or may not suit your needs. Besides, Network Manager is not suitable for advanced networking setup, such as multi-homing to more than one wired connections, forwarding network traffic, configuring Linux bridge or aliases, etc.<br><a id="more"></a><br>In general, Network Manager is designed to keep a typical end-user Linux box connected at all times with the best possible connection with minimum intervention by users. If such automation is not needed in your Linux environment, you can turn off Network Manager.</p>
<p>This tutorial describes how to disable Network Manager in various Linux desktop environments.<br>Check Which Network Interfaces are Managed by Network Manager</p>
<p>To check if Network Manager is managing any network interface, you can use nmcli, which is a command line utility that comes with Network Manager.<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nmcli dev <span class="keyword">status</span></span><br><span class="line"></span><br><span class="line">DEVICE     <span class="keyword">TYPE</span>              STATE</span><br><span class="line">eth1      <span class="number">802</span>-<span class="number">3</span>-ethernet   connected</span><br><span class="line">eth0      <span class="number">802</span>-<span class="number">3</span>-ethernet   connected</span><br></pre></td></tr></table></figure></p>
<p>The above command will list all existing network interfaces along with their STATE. If STATE is shown as &quot;unmanaged&quot;, this means Network Manager is NOT controlling a corresponding interface. If STATE displays any other values (e.g., &quot;connected&quot;), it implies that a given interface is managed by Network Manager.<br>Disable Network Manager Completely</p>
<p>Here is how to disable Network Manager completely, so that Network Manager stops running on your Linux system.</p>
<h1 id="To_disable_Network_Manager_on_Debian:">To disable Network Manager on Debian:</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.<span class="keyword">d</span>/network-manager stop</span><br><span class="line">$ sudo <span class="keyword">update</span>-rc.<span class="keyword">d</span> network-manager remove</span><br></pre></td></tr></table></figure>
<h1 id="To_disable_Network_Manager_on_Ubuntu_or_Linux_Mint:">To disable Network Manager on Ubuntu or Linux Mint:</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo stop network-manager</span><br><span class="line"><span class="variable">$ </span>echo <span class="string">"manual"</span> | sudo tee /etc/init/network-manager.override</span><br></pre></td></tr></table></figure>
<p>After disabling Network Manager on Debian or Ubuntu, use /etc/network/interfaces to configure network interfaces.</p>
<h1 id="To_disable_Network_Manager_on_Fedora:">To disable Network Manager on Fedora:</h1><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="literal">stop</span> <span class="constant">Network</span>Manager.<span class="keyword">service</span></span><br><span class="line">$ sudo systemctl disable <span class="constant">Network</span>Manager.<span class="keyword">service</span></span><br></pre></td></tr></table></figure>
<h1 id="To_disable_Network_Manager_on_CentOS:">To disable Network Manager on CentOS:</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo service <span class="constant">NetworkManager </span>stop</span><br><span class="line"><span class="variable">$ </span>sudo chkconfig <span class="constant">NetworkManager </span>off</span><br></pre></td></tr></table></figure>
<p>After disabling Network Manager on Fedora or CentOS, use /etc/sysconfig/network-scripts/ifcfg-ethX files to configure network interfaces.<br>Disable Network Manager for a Particular Network Interface on Debian, Ubuntu or Linux Mint</p>
<p>To disable Network Manager only for eth1 on Debian, Ubuntu or Linux Mint, you can do the following.</p>
<p>First, open the Network Manager configuration file in /etc/NetworkManager with a text editor, and set &quot;managed=false&quot;, typically shown under [ifupdown].<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo vi /etc/<span class="constant">NetworkManager/NetworkManager.</span>conf</span><br><span class="line"></span><br><span class="line">[ifupdown]</span><br><span class="line">managed=<span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p>Then in /etc/network/interfaces, add information about the interface you want to disable Network Manager for. In this example, the interface is eth1, and we are using static IP configuration.<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/network/interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment"># The loopback network interface</span></span><br><span class="line"><span class="type">auto</span> lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"><span class="comment"># network interface not managed by Network Manager</span></span><br><span class="line">allow-hotplug eth1</span><br><span class="line">iface eth1 inet <span class="keyword">static</span></span><br><span class="line">address <span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">10</span></span><br><span class="line">netmask <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span></span><br><span class="line">gateway <span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line">dns-nameservers <span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>Then Network Manager automatically ignore any interfaces specified in /etc/network/interfaces, and stop managing them.</p>
<p>After rebooting, verify that Network Manager is successfully disabled for eth1.<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nmcli dev status</span><br></pre></td></tr></table></figure></p>
<p>Disable Network Manager for a Particular Network Interface on Fedora or CentOS</p>
<p>The following steps will disable Network Manager for eth1 on Fedora, CentOS or RHEL.</p>
<p>Create an interface configuration file for eth1 (if not exist), and add &quot;NM_CONTROLLED=no&quot;.</p>
<p>Enable network service so that eth1 is activated by network service automatically upon boot.<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chkconfig network <span class="function_start"><span class="keyword">on</span></span></span><br></pre></td></tr></table></figure></p>
<p>Upon rebooting, verify that Network Manager is successfully disabled for eth1 with nmcli command.<br>$ nmcli dev status<br><a href="http://xmodulo.com/disable-network-manager-linux.html" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Network Manager is a feature-rich network configuration service which is used by default in most Linux desktop environments nowadays. It provides automatic configuration of (wired/wireless) network interfaces, as well as VPN, mobile broadband and even Bluetooth connections. Network Manager is smart enough to automatically switch to the best (or the most recent) connection network, and can inform other applications of up-to-date network events via D-Bus API.</p>
<p>While Network Manager comes with various sophisticated features, you might just prefer the old plain network service. There could be several reasons to do so. For one, you may wish to have more control over network management, instead of relying on purely automatic configuration and switch-over, which may or may not suit your needs. Besides, Network Manager is not suitable for advanced networking setup, such as multi-homing to more than one wired connections, forwarding network traffic, configuring Linux bridge or aliases, etc.<br>]]>
    
    </summary>
    
      <category term="network-manager" scheme="http://tiandechi.com/tags/network-manager/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux环境获取系统性能数据]]></title>
    <link href="http://tiandechi.com/2015/05/10/Linux%E7%8E%AF%E5%A2%83%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE/"/>
    <id>http://tiandechi.com/2015/05/10/Linux环境获取系统性能数据/</id>
    <published>2015-05-10T05:01:52.000Z</published>
    <updated>2015-05-10T05:03:03.593Z</updated>
    <content type="html"><![CDATA[<h1 id="CPU利用率">CPU利用率</h1><p>/proc/stat文件里包含系统cpu使用情况，2-8列对应的CPU消耗含义是用户态消耗(user)、用户态nice消耗(nice)、内 核态消耗(sys)、空闲时间(idle)、等待IO消耗(iowait)、硬件中断消耗(hardirq)、软中断消耗(softirq)。（man proc）</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cat /<span class="keyword">proc</span>/stat</span><br><span class="line">cpu  <span class="number">2339504870</span> <span class="number">2641995</span> <span class="number">716723851</span> <span class="number">70316975284</span> <span class="number">7219566</span> <span class="number">328971</span> <span class="number">304057999</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu0 <span class="number">211214357</span> <span class="number">275710</span> <span class="number">57674236</span> <span class="number">2778331292</span> <span class="number">3688175</span> <span class="number">10421</span> <span class="number">12279511</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu1 <span class="number">140100049</span> <span class="number">278788</span> <span class="number">47142039</span> <span class="number">2857686940</span> <span class="number">180452</span> <span class="number">32028</span> <span class="number">14960093</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>要计算t1~t2时间内系统的cpu利用率，需要在t1、t2时刻分别采集cpu使用信息<br><a id="more"></a><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1_all = t1<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq)</span></span><br><span class="line">t1_used = t1<span class="list">(<span class="keyword">user</span> + nice + sys + iowait + hardirq + sortirq)</span></span><br><span class="line">t2_all = t2<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq</span><br><span class="line">t2_used = t2<span class="list">(<span class="keyword">user</span> + nice + sys + iowait + hardirq + sortirq)</span></span><br><span class="line"></span><br><span class="line">cpu_usage = <span class="list">(<span class="keyword">t2_used</span> - t1_used)</span> / <span class="list">(<span class="keyword">t2_all</span> - t1_all)</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="进程CPU利用率">进程CPU利用率</h1><p>/proc/$pid/stat文件里包含某个进程的cpu使用信息，14、15、16、17列对应进程用户态消耗(user)、内核态消耗(sys)、用户态等待子进程的消耗(user_child)、内核态等待子进程的消耗(sys_child)。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$cat /<span class="keyword">proc</span>/<span class="number">24076</span>/stat</span><br><span class="line"><span class="number">24076</span> (redis-server) S <span class="number">1</span> <span class="number">24076</span> <span class="number">24076</span> <span class="number">0</span> -<span class="number">1</span> <span class="number">4202560</span> <span class="number">5755</span> <span class="number">147</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1864</span> <span class="number">3298</span> <span class="number">0</span> <span class="number">0</span> <span class="number">20</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">70238536</span> <span class="number">159555584</span> <span class="number">5145</span> <span class="number">18446744073709551615</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4097</span> <span class="number">17610</span> <span class="number">18446744073709551615</span> <span class="number">0</span> <span class="number">0</span> <span class="number">17</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>t1、t2时刻分别采集/proc/stat、/proc/$pid/stat，获取总的cpu消耗，以及进程的cpu消耗<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t1_all = t1<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq)</span></span><br><span class="line">t1_pid = t1<span class="list">(<span class="keyword">user</span> + sys + user_child + sys_child)</span></span><br><span class="line">t2_all = t2<span class="list">(<span class="keyword">user</span> + nice + sys + idle + iowait + hardirq + sortirq)</span></span><br><span class="line">t2_pid = t2<span class="list">(<span class="keyword">user</span> + sys + user_child + sys_child)</span></span><br><span class="line"></span><br><span class="line">pid_cpu_usage = <span class="list">(<span class="keyword">t2_pid</span> - t1_pid)</span> / <span class="list">(<span class="keyword">t2_all</span> - t1_all)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="内存利用率">内存利用率</h1><p>/proc/meminfo文件里包含系统内存使用信息</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/meminfo</span><br><span class="line"><span class="type">MemTotal</span>:       <span class="number">198450624</span> kB</span><br><span class="line"><span class="type">MemFree</span>:        <span class="number">184950332</span> kB</span><br><span class="line"></span><br><span class="line">mem_usage = <span class="number">1</span> - <span class="type">MemFree</span> / <span class="type">MemTotal</span></span><br></pre></td></tr></table></figure>
<h1 id="系统load">系统load</h1><p>/proc/uptime的前3列包含了最近1min、5min、15min系统的平均load（正在运行或等待IO的进程数，进程state为R或D）</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$cat /<span class="keyword">proc</span>/loadavg</span><br><span class="line"><span class="number">0</span>.<span class="number">02</span> <span class="number">0</span>.<span class="number">09</span> <span class="number">0</span>.<span class="number">08</span> <span class="number">1</span>/<span class="number">2362</span> <span class="number">855</span></span><br></pre></td></tr></table></figure>
<h1 id="网卡流量信息">网卡流量信息</h1><p>/proc/net/dev包含所有网卡的流量信息，第1、2、10、11列分别代表网卡当前接受字节数（recv_bytes）、接受包个数(recv_packets)、发送字节数(send_bytes)、发送个数(send_packets)。</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /<span class="keyword">proc</span>/net/dev<span class="symbol"></span><br><span class="line">Inter-|</span> <span class="symbol">  Receive</span>                                                |<span class="symbol">  Transmit</span></span><br><span class="line"><span class="symbol"> face</span> |bytes<span class="symbol">    packets</span> errs<span class="symbol"> drop</span> fifo<span class="symbol"> frame</span> compressed<span class="symbol"> multicast|bytes</span> <span class="symbol">   packets</span> errs<span class="symbol"> drop</span> fifo<span class="symbol"> colls</span> <span class="symbol">    carrier</span> compressed<span class="symbol"></span><br><span class="line"> lo:25047448261</span> 37947893    0    0    0     0          0         0 25047448261 37947893    0    0    0     0       0          0<span class="symbol"></span><br><span class="line"> eth0:2566932970457</span> 7620547348    0    0    2     0          0     62732 728662220296 6145797287    0    0    0     0       0          0<span class="symbol"></span><br><span class="line"> eth1:2023304550582</span> 7268848253    0    0    0     0          0     77924 742443231982 6129090809    0    0    0     0       0          0</span><br></pre></td></tr></table></figure>
<p>t1~t2时间内的平均流量为<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avg_recv_bytes = <span class="list">(<span class="keyword">t2_recv_bytes</span> - t1_recv_bytes)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_send_bytes = <span class="list">(<span class="keyword">t2_send_bytes</span> - t1_send_bytes)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="磁盘（文件系统）空间信息">磁盘（文件系统）空间信息</h1><p>通过statfs系统调用可获取当前文件系统的空间占用情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> statfs &#123;</span><br><span class="line">    <span class="keyword">long</span>    f_type;     <span class="comment">/* type of file system (see below) */</span></span><br><span class="line">    <span class="keyword">long</span>    f_bsize;    <span class="comment">/* optimal transfer block size */</span></span><br><span class="line">    <span class="keyword">long</span>    f_blocks;   <span class="comment">/* total data blocks in file system */</span></span><br><span class="line">    <span class="keyword">long</span>    f_bfree;    <span class="comment">/* free blocks in fs */</span></span><br><span class="line">    <span class="keyword">long</span>    f_bavail;   <span class="comment">/* free blocks avail to non-superuser */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">disk_usage = <span class="number">1</span> - f_bfree / f_blocks</span><br></pre></td></tr></table></figure>
<h1 id="磁盘读写信息">磁盘读写信息</h1><p>/proc/diskstats包含磁盘的IO信息，第4-9列分别为当前磁盘读次数(read)，磁盘读扇区数(read_sec)、磁盘读毫秒数(read_ms)、磁盘写次数(write)、磁盘写扇区数(write_sec)、磁盘写毫秒数(write_ms)。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cat /<span class="keyword">proc</span>/diskstats</span><br><span class="line"><span class="number">8</span>       <span class="number">4</span> sda4 <span class="number">3</span> <span class="number">0</span> <span class="number">12</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span>       <span class="number">5</span> sda5 <span class="number">87928</span> <span class="number">55284</span> <span class="number">2842138</span> <span class="number">17349</span> <span class="number">1230958</span> <span class="number">7932106</span> <span class="number">73380432</span> <span class="number">4931382</span> <span class="number">0</span> <span class="number">503343</span> <span class="number">4947504</span></span><br><span class="line"><span class="number">8</span>      <span class="number">16</span> sdb <span class="number">393</span> <span class="number">35</span> <span class="number">3418</span> <span class="number">37</span> <span class="number">17</span> <span class="number">2</span> <span class="number">152</span> <span class="number">0</span> <span class="number">0</span> <span class="number">37</span> <span class="number">37</span></span><br><span class="line"><span class="number">8</span>      <span class="number">32</span> sdc <span class="number">788</span> <span class="number">114</span> <span class="number">10690</span> <span class="number">10132</span> <span class="number">14550036</span> <span class="number">226568635</span> <span class="number">1929026928</span> <span class="number">623148463</span> <span class="number">0</span> <span class="number">4917530</span> <span class="number">623154797</span></span><br></pre></td></tr></table></figure>
<p>t1~t2时间内磁盘平均读写次数、扇区数、IO利用率计算如下<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avg_read = <span class="list">(<span class="keyword">t2_read</span> - t1_read)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_read_sec = <span class="list">(<span class="keyword">t2_read_sec</span> - t1_read_sec)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_write = <span class="list">(<span class="keyword">t2_write</span> - t1_write)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">avg_write_sec = <span class="list">(<span class="keyword">t2_write_sec</span> - t1_write_sec)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span></span><br><span class="line">io_util = <span class="list">(<span class="keyword">t2_read_ms</span> + t2_write_ms - t1_read_ms - t1_write_ms)</span> / <span class="list">(<span class="keyword">t2</span> - t1)</span> <span class="list">(<span class="keyword">t1</span>~t2时间段内IO</span></span><br></pre></td></tr></table></figure></p>
<p><a href="http://www.linuxidc.com/Linux/2015-05/117278.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="CPU利用率">CPU利用率</h1><p>/proc/stat文件里包含系统cpu使用情况，2-8列对应的CPU消耗含义是用户态消耗(user)、用户态nice消耗(nice)、内 核态消耗(sys)、空闲时间(idle)、等待IO消耗(iowait)、硬件中断消耗(hardirq)、软中断消耗(softirq)。（man proc）</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cat /<span class="keyword">proc</span>/stat</span><br><span class="line">cpu  <span class="number">2339504870</span> <span class="number">2641995</span> <span class="number">716723851</span> <span class="number">70316975284</span> <span class="number">7219566</span> <span class="number">328971</span> <span class="number">304057999</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu0 <span class="number">211214357</span> <span class="number">275710</span> <span class="number">57674236</span> <span class="number">2778331292</span> <span class="number">3688175</span> <span class="number">10421</span> <span class="number">12279511</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">cpu1 <span class="number">140100049</span> <span class="number">278788</span> <span class="number">47142039</span> <span class="number">2857686940</span> <span class="number">180452</span> <span class="number">32028</span> <span class="number">14960093</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>要计算t1~t2时间内系统的cpu利用率，需要在t1、t2时刻分别采集cpu使用信息<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[win7 32位与64位下载地址存档]]></title>
    <link href="http://tiandechi.com/2015/05/10/win7-32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%AD%98%E6%A1%A3/"/>
    <id>http://tiandechi.com/2015/05/10/win7-32位与64位下载地址存档/</id>
    <published>2015-05-10T04:58:22.000Z</published>
    <updated>2015-05-10T05:12:20.716Z</updated>
    <content type="html"><![CDATA[<h1 id="Windows_7_简体中文旗舰版_x86_(32位_MSDN_RTM正式版)">Windows 7 简体中文旗舰版 x86 (32位 MSDN RTM正式版)</h1><p><a href="ed2k://%7Cfile%7Ccn_windows_7_ultimate_with_sp1_x86_dvd_618763.iso%7C2651877376%7CD6A0D9FDB8C67A65B92B4C1AC197109C%7C/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_Ultimate_(x64)-DVD(English)">Windows 7 Ultimate (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_x64_dvd_X15-65922.iso|3224686592|6719AFC5486F38BE75F2DF39C8527113|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_Ultimate_N_(x64)-DVD(English)">Windows 7 Ultimate N (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_n_x64_dvd_x16-13641.iso|2908555264|C014B86268602565B7880933B41F21AC|/" target="_blank" rel="external">下载地址</a><br><a id="more"></a></p>
<h1 id="Windows_7_Ultimate_with_Service_Pack_1_(x64)-DVD(English)">Windows 7 Ultimate with Service Pack 1 (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_with_sp1_x64_dvd_618240.iso|3319478272|004498E6851D90B5E025049604942C86|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_Ultimate_with_Service_Pack_1_(x64)-DVD(English)-1">Windows 7 Ultimate with Service Pack 1 (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_with_sp1_x64_dvd_u_677332.iso|3320903680|743598C64E635C72964CF02A3E0AD547|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(简体中文)">Windows 7 旗舰版 (x64)-DVD(简体中文)</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_x64_dvd_x15-66043.iso|3341268992|7DD7FA757CE6D2DB78B6901F81A6907A|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_含SP1(x64)-DVD(简体中文)">Windows 7 旗舰版 含SP1(x64)-DVD(简体中文)</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_618537.iso|3419052032|56E90251E665E643C81168F6DD870BCB|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_含SP1(x64)-DVD(简体中文)-1">Windows 7 旗舰版 含SP1(x64)-DVD(简体中文)</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(中文-香港特别行政区)">Windows 7 旗舰版 (x64)-DVD(中文-香港特别行政区)</h1><p><a href="ed2k://|file|hk_windows_7_ultimate_x64_dvd_x15-65911.iso|3313936384|917F16D04FBBFDE763A35E2A32595AD9|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(中文-香港特别行政区)-1">Windows 7 旗舰版 (x64)-DVD(中文-香港特别行政区)</h1><p><a href="ed2k://|file|hk_windows_7_ultimate_with_sp1_x64_dvd_618544.iso|3390910464|BE5F84D28F5DA939EEFDB9498D4F986D|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="Windows_7_旗舰版_(x64)-DVD(中文-香港特别行政区)-2">Windows 7 旗舰版 (x64)-DVD(中文-香港特别行政区)</h1><p><a href="ed2k://|file|hk_windows_7_ultimate_with_sp1_x64_dvd_u_677411.iso|3392374784|C8DFF761AD8DD1B9137887954942B803|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="win7_32位旗舰版">win7 32位旗舰版</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x86_dvd_u_677486.iso|2653276160|7503E4B9B8738DFCB95872445C72AEFB|/" target="_blank" rel="external">下载地址</a></p>
<h1 id="win7_64位旗舰版">win7 64位旗舰版</h1><p><a href="ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/" target="_blank" rel="external">下载地址</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Windows_7_简体中文旗舰版_x86_(32位_MSDN_RTM正式版)">Windows 7 简体中文旗舰版 x86 (32位 MSDN RTM正式版)</h1><p><a href="ed2k://%7Cfile%7Ccn_windows_7_ultimate_with_sp1_x86_dvd_618763.iso%7C2651877376%7CD6A0D9FDB8C67A65B92B4C1AC197109C%7C/">下载地址</a></p>
<h1 id="Windows_7_Ultimate_(x64)-DVD(English)">Windows 7 Ultimate (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_x64_dvd_X15-65922.iso|3224686592|6719AFC5486F38BE75F2DF39C8527113|/">下载地址</a></p>
<h1 id="Windows_7_Ultimate_N_(x64)-DVD(English)">Windows 7 Ultimate N (x64)-DVD(English)</h1><p><a href="ed2k://|file|en_windows_7_ultimate_n_x64_dvd_x16-13641.iso|2908555264|C014B86268602565B7880933B41F21AC|/">下载地址</a><br>]]>
    
    </summary>
    
      <category term="32位" scheme="http://tiandechi.com/tags/32%E4%BD%8D/"/>
    
      <category term="64位" scheme="http://tiandechi.com/tags/64%E4%BD%8D/"/>
    
      <category term="Downloads" scheme="http://tiandechi.com/tags/Downloads/"/>
    
      <category term="Win7" scheme="http://tiandechi.com/tags/Win7/"/>
    
      <category term="ed2k" scheme="http://tiandechi.com/tags/ed2k/"/>
    
      <category term="Windows" scheme="http://tiandechi.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[regular expression tutorial in 30 minutes]]></title>
    <link href="http://tiandechi.com/2015/05/04/regular-expression-tutorial-in-30-minutes/"/>
    <id>http://tiandechi.com/2015/05/04/regular-expression-tutorial-in-30-minutes/</id>
    <published>2015-05-04T11:03:17.000Z</published>
    <updated>2015-05-04T03:07:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="本文目标">本文目标</h1><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>
<h1 id="如何使用本教程">如何使用本教程</h1><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。<br>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？<br><a id="more"></a><br><strong>详情查看<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">来源</a></strong></p>
<h1 id="正则表达式到底是什么东西？">正则表达式到底是什么东西？</h1><h1 id="入门">入门</h1><h1 id="测试正则表达式">测试正则表达式</h1><h1 id="元字符">元字符</h1><h1 id="字符转义">字符转义</h1><h1 id="重复">重复</h1><h1 id="字符类">字符类</h1><h1 id="分枝条件">分枝条件</h1><h1 id="反义">反义</h1><h1 id="分组">分组</h1><h1 id="后向引用">后向引用</h1><h1 id="零宽断言">零宽断言</h1><h1 id="负向零宽断言">负向零宽断言</h1><h1 id="注释">注释</h1><h1 id="贪婪与懒惰">贪婪与懒惰</h1><h1 id="处理选项">处理选项</h1><h1 id="平衡组/递归匹配">平衡组/递归匹配</h1><h1 id="还有些什么东西没提到">还有些什么东西没提到</h1><h1 id="联系作者">联系作者</h1><h1 id="网上的资源及本文参考文献">网上的资源及本文参考文献</h1><h1 id="更新纪录">更新纪录</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="本文目标">本文目标</h1><p>30分钟内让你明白正则表达式是什么，并对它有一些基本的了解，让你可以在自己的程序或网页里使用它。</p>
<h1 id="如何使用本教程">如何使用本教程</h1><p>别被下面那些复杂的表达式吓倒，只要跟着我一步一步来，你会发现正则表达式其实并没有想像中的那么困难。当然，如果你看完了这篇教程之后，发现自己明白了很多，却又几乎什么都记不得，那也是很正常的——我认为，没接触过正则表达式的人在看完这篇教程后，能把提到过的语法记住80%以上的可能性为零。这里只是让你明白基本的原理，以后你还需要多练习，多使用，才能熟练掌握正则表达式。<br>除了作为入门教程之外，本文还试图成为可以在日常工作中使用的正则表达式语法参考手册。就作者本人的经历来说，这个目标还是完成得不错的——你看，我自己也没能把所有的东西记下来，不是吗？<br>]]>
    
    </summary>
    
      <category term="regular expression" scheme="http://tiandechi.com/tags/regular-expression/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[log in SSH with no password]]></title>
    <link href="http://tiandechi.com/2015/05/04/log-in-SSH-with-no-password/"/>
    <id>http://tiandechi.com/2015/05/04/log-in-SSH-with-no-password/</id>
    <published>2015-05-04T11:02:11.000Z</published>
    <updated>2015-05-04T03:08:58.000Z</updated>
    <content type="html"><![CDATA[<p>SSH无密码登录要使用公钥与私钥。Linux下可以用用ssh-keygen生成公钥/私钥对，下面我以CentOS为例。</p>
<p>有机器A(192.168.1.155)，B(192.168.1.181)。现想A通过ssh免密码登录到B。<br><a id="more"></a></p>
<h1 id="在A机下生成公钥/私钥对。">在A机下生成公钥/私钥对。</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[linuxidc<span class="variable">@A</span> ~]<span class="variable">$ </span>ssh-keygen -t rsa -<span class="constant">P </span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>-P表示密码，-P &#39;&#39; 就表示空密码，也可以不用-P参数，这样就要三车回车，用-P就一次回车。<br>它在/home/linuxidc下生成.ssh目录，.ssh下有id_rsa和id_rsa.pub。</p>
<h1 id="把A机下的id_rsa-pub复制到B机下，在B机的-ssh/authorized_keys文件里，我用scp复制。">把A机下的id_rsa.pub复制到B机下，在B机的.ssh/authorized_keys文件里，我用scp复制。</h1><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[linuxidc<span class="variable">@A</span> ~]<span class="variable">$ </span>scp .ssh/id_rsa.pub linuxidc<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">181</span><span class="symbol">:/home/linuxidc/id_rsa</span>.pub </span><br><span class="line">linuxidc<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">181</span><span class="string">'s password:</span><br><span class="line">id_rsa.pub 100% 223 0.2KB/s 00:00</span></span><br></pre></td></tr></table></figure>
<p>由于还没有免密码登录的，所以要输入密码。</p>
<h1 id="B机把从A机复制的id_rsa-pub添加到-ssh/authorzied_keys文件里。">B机把从A机复制的id_rsa.pub添加到.ssh/authorzied_keys文件里。</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[linuxidc<span class="variable">@B</span> ~]<span class="variable">$ </span>cat id_rsa.pub <span class="prompt">&gt;&gt; </span>.ssh/authorized_keys</span><br><span class="line">[linuxidc<span class="variable">@B</span> ~]<span class="variable">$ </span>chmod <span class="number">600</span> .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>authorized_keys的权限要是<strong>600</strong>。</p>
<h1 id="A机登录B机。">A机登录B机。</h1><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">linuxidc@A</span> ~]$ ssh <span class="number">192.168</span>.1.181</span><br><span class="line">The authenticity of host <span class="variable">'192.168.1.181</span> <span class="list">(<span class="keyword">192.168.1.181</span>)</span>' can<span class="variable">'t</span> be established.</span><br><span class="line">RSA key fingerprint is <span class="number">00</span>:a6:a8:87:eb:c7:40:10:39:cc:a0:eb:50:d9:6a:5b.</span><br><span class="line">Are you sure you want to continue connecting <span class="list">(<span class="keyword">yes/no</span>)</span>? yes</span><br><span class="line">Warning: Permanently added <span class="variable">'192.168.1.181</span>' <span class="list">(<span class="keyword">RSA</span>)</span> to the list of known hosts.</span><br><span class="line">Last login: Thu Jul <span class="number">3</span> <span class="number">09</span>:53:18 <span class="number">2008</span> from linuxidc</span><br><span class="line"><span class="list">[<span class="keyword">chenlb@B</span> ~]$</span></span></span><br></pre></td></tr></table></figure>
<p>第一次登录是时要你输入yes。</p>
<h1 id="现在A机可以无密码登录B机了。">现在A机可以无密码登录B机了。</h1><p>小结：登录的机子可有私钥，被登录的机子要有登录机子的公钥。这个公钥/私钥对一般在私钥宿主机产生。上面是用rsa算法的公钥/私钥对，当然也可以用dsa(对应的文件是id_dsa，id_dsa.pub)</p>
<p>想让A，B机无密码互登录，那B机以上面同样的方式配置即可。</p>
<p><a href="http://www.linuxidc.com/Linux/2015-05/116908.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>SSH无密码登录要使用公钥与私钥。Linux下可以用用ssh-keygen生成公钥/私钥对，下面我以CentOS为例。</p>
<p>有机器A(192.168.1.155)，B(192.168.1.181)。现想A通过ssh免密码登录到B。<br>]]>
    
    </summary>
    
      <category term="SSH" scheme="http://tiandechi.com/tags/SSH/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[find command]]></title>
    <link href="http://tiandechi.com/2015/05/04/find-command/"/>
    <id>http://tiandechi.com/2015/05/04/find-command/</id>
    <published>2015-05-04T10:59:37.000Z</published>
    <updated>2015-05-04T03:01:28.000Z</updated>
    <content type="html"><![CDATA[<p>find 命令算是Linux下最常用的一个命令之一了，这里有一些常用用法的总结。</p>
<ol>
<li><p>按文件名搜索<br>搜索当前目录下所有的以txt结尾的文件。第二个命令用了 -exec 参数，可以在对查找的所有文件执行一种操作。注意格式，空格和;一个都不能少。-name 的参数可以用正则表达式，例如第二个例子</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./* -<span class="property">name</span> <span class="string">"*.txt"</span></span><br><span class="line">find ./* -<span class="property">name</span> <span class="string">"[ab]*.py"</span></span><br><span class="line">find ./* -<span class="property">name</span> <span class="string">"*.pyc"</span> -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按修改时间查找<br>查找当前目录下当天修改过的文件。-1 表示一天前修改过的文件。-2表示前两天。find ./<em> -mtime n n表示，对文件数据的最近一次修改是在 n</em>24 小时之前。+n 指n天以前，-n指n天以内(对 -mmin 是指n分钟), n 表示第n天，他们的含义都是不同的，注意区分。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./* -mtime <span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span> </span><br><span class="line"><span class="built_in">find</span> ./* -mmin -<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br><span class="line"><span class="built_in">find</span> ./* -mmin +<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件状态改变<br>和上个参数相比，基本道理都是一样的，只不过这个参数的含义是文件的权限被修改。改内容和改文件的权限是不一样的，这里指的是更改的是文件inode的数据，比如文件的权限，所属人等等信息。cmin 表示近60分钟内被改过权限，ctime 表示近几天内被修改过。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./* -cmin +<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br><span class="line"><span class="built_in">find</span> ./* -ctime -<span class="number">60</span> -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>按照文件的所属group和 所属user 来查找<br>-user 和 -nouser 最后一个命令找出当前已经被删除的系统用户的所有文件， - group 和 - nogroup 的功能类似。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./* -user fox</span><br><span class="line"><span class="built_in">find</span> ./* -nouser</span><br></pre></td></tr></table></figure>
</li>
<li><p>find 避开某个目录,避开多个目录。<br>其中 -a 表示 and 的意思，-o 表示or 的意思。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> test -<span class="built_in">path</span> "test/test4" -prune -o -<span class="built_in">print</span></span><br><span class="line"><span class="built_in">find</span> test \( -<span class="built_in">path</span> test/test4 -o -<span class="built_in">path</span> test/test3 \) -prune -o -<span class="built_in">print</span> </span><br><span class="line"><span class="built_in">find</span> . \( -<span class="built_in">path</span> ./modules -o -<span class="built_in">path</span> ./framework -o -<span class="built_in">path</span> ./utils -o -<span class="built_in">path</span> ./config \) -prune -o -name "Bigger.*" -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-perm 选项 指文件的访问权限</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> -perm <span class="number">755</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实用inode 来查找文件编号。可以如下面所示在find命令中指定inode编号。在此，find命令用inode编号重命名了一个文件。你也可以通过rm来删除那个特殊的文件。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -i1 test*</span><br><span class="line">16187429 test-file-name</span><br><span class="line">16187430 test-file-name</span><br><span class="line">find -inum 16187430 -exec mv &#123;&#125;<span class="instruction"> new-test-file-name </span>\;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找出当前目录下最大的5个文件</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="keyword">type</span> f -exec <span class="keyword">ls</span> -s &#123;&#125; \; | <span class="keyword">sort</span> -<span class="keyword">n</span> -r | head -5</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的命令删除大于100M的*.zip文件。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -<span class="keyword">type</span> f -<span class="keyword">name</span> *.zip -<span class="built_in">size</span> +00M -exec rm -i &#123;&#125; \;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="http://www.linuxidc.com/Linux/2015-04/116854.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>find 命令算是Linux下最常用的一个命令之一了，这里有一些常用用法的总结。</p>
<ol>
<li><p>按文件名搜索<br>搜索当前目录下所有的以txt结尾的文件。第二个命令用了 -exec 参数，可以在对查找的所有文件执行一种操作。注意格式，空格和;一个都不能少]]>
    </summary>
    
      <category term="commands" scheme="http://tiandechi.com/tags/commands/"/>
    
      <category term="find" scheme="http://tiandechi.com/tags/find/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[how to enter single user mode and crack root password in Linux]]></title>
    <link href="http://tiandechi.com/2015/04/29/how-to-enter-single-user-mode-and-crack-root-password-in-Linux/"/>
    <id>http://tiandechi.com/2015/04/29/how-to-enter-single-user-mode-and-crack-root-password-in-Linux/</id>
    <published>2015-04-29T11:37:52.000Z</published>
    <updated>2015-04-29T03:38:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="linux下如何进入单人维护模式">linux下如何进入单人维护模式</h1><p>先将系统重新开机，在读秒的时候按下任意键就会出现操作系统的选择画面，仔细看选单底下的说明， 按下『e』就能进入grub的编辑模式了。此時你看到的画面有点像底下这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root (hd0,<span class="number">0</span>)</span><br><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span> ro root=LABEL=/ rhgb quiet</span><br><span class="line">initrd /initrd-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span><span class="class">.img</span></span><br></pre></td></tr></table></figure></p>
<p>此时，请将游标移动到kernel那一行，再按一次『 e 』进入kernel该行的编辑画面中， 然后在出现的画面<br>当中，最后方输入 “single” ：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span>.el5 ro <span class="variable">root=</span><span class="variable">LABEL=</span>/ rhgb quiet single</span><br></pre></td></tr></table></figure></p>
<p>再按下『 Enter 』確定之後，按下 b 就可以开机進入单人维护模式了！<br>在这个模式底下，你会在tty1的地方不需要输入密码即可取得终端机的控制权(而且是使用root的身份喔！)。</p>
<h1 id="各个Linux版本的本地root密码破解方法">各个Linux版本的本地root密码破解方法</h1><a id="more"></a>
<p>这段时间老碰到有人问及各个linux版本的本地root密码破解方法，我这里自己以及在网络上搜集了些资料，希望对看到了这文章而又恰好用得到的技术人员有点帮助：</p>
<h2 id="RedHat/CentOS/Fedora_系统密码破解">RedHat/CentOS/Fedora 系统密码破解</h2><ol>
<li>在grub选项菜单按E进入编辑模式</li>
<li>编辑kernel 那行最后加上S (或者Single）</li>
<li>按B，启动到single-user mode</li>
<li>进入后执行下列命令<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># mount -t proc proc /proc</span></span><br><span class="line"><span class="preprocessor"># mount -o remount,rw /</span></span><br><span class="line"><span class="preprocessor">#passwd</span></span><br><span class="line"><span class="preprocessor">#sync</span></span><br><span class="line"><span class="preprocessor">#reboot</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>【1】开机画面按e进入<br>【2】进入以下的画面后，选择如下所示的选项，再次按下e按钮； 1 S Single都可以<br>【3】返回到当前页后，按下b按钮起动linux；<br>【4】用passwd命令修改root用户密码；<br>【5】利用shutdown -r now命令重启linux，密码修改完毕。</p>
<h2 id="Debian_linux_系统密码破解">Debian linux 系统密码破解</h2><ol>
<li>在grub选项菜单&#39;Debian GNU/Linux,...(recovery mode)&#39;，按e进入编辑模式</li>
<li>编辑kernel那行最后面的 ro single 改成 rw single init=/bin/bash，按b执行重启</li>
<li>进入后执行下列命令<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@(<span class="attribute">none</span>)<span class="id">#mount</span> -<span class="tag">a</span></span><br><span class="line">root@(<span class="attribute">none</span>)<span class="id">#passwd</span> root</span><br><span class="line">root@(<span class="attribute">none</span>)#reboot</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Freebsd_系统密码破解">Freebsd 系统密码破解</h2><ol>
<li>开机进入引导菜单</li>
<li>选择每项(按4)进入单用户模式</li>
<li>进入之后输入一列命令<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="id">#mount</span> -<span class="tag">a</span></span><br><span class="line">root@<span class="id">#fsck</span> -y</span><br><span class="line">root@#<span class="function"><span class="title">passwd</span><span class="params">(修改密码命令)</span></span></span><br><span class="line">root@#<span class="function"><span class="title">root</span><span class="params">(要破解密码的用户名)</span></span></span><br><span class="line">Enter new unix password:</span><br><span class="line">root@<span class="id">#init</span> <span class="number">6</span> (重启)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Solaris_系统密码破解">Solaris 系统密码破解</h2><ol>
<li>在grub选项菜中选择solaris failasfe 项</li>
<li>系统提示Do you wish to have it mounted read-write on /a ?[y,n,?] 选择y</li>
<li>就进入单用户模式</li>
<li>输入下列命令:<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br><span class="line">root@<span class="title">#init 6</span> <span class="comment">(重启)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="NetBsd_系统密码破解">NetBsd 系统密码破解</h2><ol>
<li><p>开机：当出现提示符号并开始倒数五秒时， 键入以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; boot <span class="operator">-s</span> (进入单用户模式命令)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在以下的提示符号中</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter pathname <span class="operator">of</span> <span class="built_in">shell</span> <span class="operator">or</span> <span class="constant">RETURN</span> <span class="keyword">for</span> sh:</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>按下 Enter。</p>
<ol>
<li><p>键入以下指令：</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># mount -a</span></span><br><span class="line"><span class="preprocessor"># fsck -y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 passwd 更改 root 的密码。</p>
</li>
<li>使用 exit 指令进入多人模式。<h2 id="SUSE_系统密码破解">SUSE 系统密码破解</h2></li>
<li>重新启动机器，在出现grub引导界面后，在启动linux的选项里加上init=/bin/bash，通过给内核传递init=/bin/bash参数使得OS在运行login程序之前运行bash，出现命令行。</li>
<li>稍等片刻出现(none)#:命令行。</li>
<li>这时输入mount -n / -o remount,rw 表示将根文件系统重新mount为可读写，有了读写权限后就可以通过passwd命令修改密码了。</li>
<li>这时输入passwd命令就可以重置密码了</li>
<li>修改完成后记得用mount -n / -o remount,ro将根文件系统置为原来的状态。</li>
</ol>
<p><a href="http://blog.csdn.net/vagrant2005/article/details/6561637" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="linux下如何进入单人维护模式">linux下如何进入单人维护模式</h1><p>先将系统重新开机，在读秒的时候按下任意键就会出现操作系统的选择画面，仔细看选单底下的说明， 按下『e』就能进入grub的编辑模式了。此時你看到的画面有点像底下这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root (hd0,<span class="number">0</span>)</span><br><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span> ro root=LABEL=/ rhgb quiet</span><br><span class="line">initrd /initrd-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span><span class="class">.el5</span><span class="class">.img</span></span><br></pre></td></tr></table></figure></p>
<p>此时，请将游标移动到kernel那一行，再按一次『 e 』进入kernel该行的编辑画面中， 然后在出现的画面<br>当中，最后方输入 “single” ：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel /vmlinuz-<span class="number">2.6</span>.<span class="number">18</span>-<span class="number">128</span>.el5 ro <span class="variable">root=</span><span class="variable">LABEL=</span>/ rhgb quiet single</span><br></pre></td></tr></table></figure></p>
<p>再按下『 Enter 』確定之後，按下 b 就可以开机進入单人维护模式了！<br>在这个模式底下，你会在tty1的地方不需要输入密码即可取得终端机的控制权(而且是使用root的身份喔！)。</p>
<h1 id="各个Linux版本的本地root密码破解方法">各个Linux版本的本地root密码破解方法</h1>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[some Linux tests]]></title>
    <link href="http://tiandechi.com/2015/04/29/some-Linux-tests/"/>
    <id>http://tiandechi.com/2015/04/29/some-Linux-tests/</id>
    <published>2015-04-29T11:35:33.000Z</published>
    <updated>2015-04-29T03:47:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="上部">上部</h1><ol>
<li><p>如何更改linux主机名？<br>编辑配置文件 /etc/sysconfig/network<br>更改HOSTSNAME，保存退出后重启生效；</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="property">@yonglinux</span> ~]<span class="comment"># cat /etc/sysconfig/network</span></span><br><span class="line">NETWORKING=<span class="literal">yes</span></span><br><span class="line">HOSTNAME=yonglinux.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录linux，我们除了使用密码验证，还可以使用哪种方式？简述配置过程。<br>使用密钥加密登录，客户端生成公钥和私钥，客户端保存私钥，公钥复制到远程linux主机，登录时使用密钥加密登录；</p>
<a id="more"></a>
<p>在linux主机执行下面的操作：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /<span class="literal">root</span>/.ssh</span><br><span class="line">chmod  <span class="number">700</span> /<span class="literal">root</span>/.ssh</span><br><span class="line">vi /<span class="literal">root</span>/.ssh/authorized_keys    粘贴复制的公钥，保存退出；</span><br><span class="line">chmod <span class="number">600</span> /<span class="literal">root</span>/.ssh/authorized_keys</span><br><span class="line">vi /etc/<span class="built_in">selinux</span>/config    编辑<span class="built_in">selinux</span>防火墙配置</span><br><span class="line">更改 <span class="constant">S</span>ELINUX=disabled    永久关闭<span class="built_in">selinux</span>；</span><br><span class="line">iptables -<span class="constant">F</span>    清空防火墙规则；</span><br><span class="line">/etc/init.d/iptables save    保存防火墙设置；</span><br><span class="line">客户端使用密钥登录；</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何给grub加密码（明文、密文)，密文加密又分成哪几种？<br>明文加密 vi /etc/grub.conf<br>hiddenmenu下增加一行<br>password=123456<br>保存退出，重启系统进入菜单选择，按p输入密码才可以编辑；<br>密文加密分md5加密和sha加密<br>md5加密命令为：grub-md5-crypt<br>输入密码，生成一串加密后的密码，复制密码<br>vi  /etc/grub.conf<br>password --md5 粘贴密码<br>保存退出，重启系统进入菜单，按p输入密码；<br>sha加密命令：grub-crypt --sha-256<br>输入密码，生成一串密码，复制密码<br>编辑/etc/grub.conf<br>password --encrypted 粘贴密码，<br>保存退出，重启进入系统，按p输入密码；</p>
</li>
<li>如何用yum安装/删除一个软件包？如何查看某个软件包是否已经安装<br>安装：yum install -y tree<br>删除：yum remove -y tree<br>查看：rpm -qa | grep “包名” 或    rpm -q 包名</li>
<li><p>如何查看系统版本？（3个方法）</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> /etc/CentOS-release</span><br><span class="line"><span class="keyword">cat</span> /etc/issue</span><br><span class="line">rpm -<span class="keyword">qa</span> | <span class="keyword">grep</span> release</span><br></pre></td></tr></table></figure>
</li>
<li><p>find 找出 当前目录下的 目录和普通文件？ 找出当前目录下10天没有改变，大小大于4K的普通文件或目录</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ./ -<span class="keyword">type</span> <span class="keyword">d</span>  -o -<span class="keyword">type</span> <span class="literal">f</span></span><br><span class="line">find ./ -<span class="keyword">type</span> <span class="keyword">d</span> -o -<span class="keyword">type</span> f -size +4k ! -mtime -10</span><br><span class="line">-</span><br></pre></td></tr></table></figure>
</li>
<li><p>在当前目录下创建一个名字为1的目录 的命令？  创建级联目录 ./2/3/的命令？ 一条命令创建级联目录 ./1/2/3和./1/2/4?</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./<span class="number">1</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./<span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ./<span class="number">1</span>/<span class="number">2</span>/&#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cp一个目录中的文件需要什么权限，mv呢？touch呢？rm呢？<br>cp需要有目录的x权限，mv需要wx权限，touch需要wx权限，rm需要有wx权限；</p>
</li>
<li><p>用cat如何向文件里重定向字符串<br>第一种方法：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user1<span class="variable">@localhost</span> tmp]<span class="variable">$ </span>cat <span class="prompt">&gt;&gt;</span><span class="number">1</span>.txt</span><br><span class="line"><span class="number">000000000000</span></span><br><span class="line"><span class="number">111111111111</span></span><br><span class="line"><span class="number">222222222222</span></span><br><span class="line">最后按ctrl + d</span><br></pre></td></tr></table></figure>
<p>第二种方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt;<span class="number">1</span>.txt&lt;</span><br><span class="line">&gt; <span class="number">000000000000</span></span><br><span class="line">&gt; qqqqqqqqqqqqq</span><br><span class="line">&gt;<span class="function"><span class="title">EOF</span><span class="params">(这个结束)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>建立一个公共目录/opt/public,要求每个用户都可以创建文件和目录，但只能自己本人和root可以删除；</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="regexp">/opt/</span><span class="keyword">public</span></span><br><span class="line">chmod <span class="number">1777</span> <span class="regexp">/opt/</span><span class="keyword">public</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="下部">下部</h1><ol>
<li><p>如何查看当前用户的家目录是什么?</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果设置 umask 为 001 , 那么用户默认创建的目录和文件的权限是什么样子的？<br>创建的目录为766，文件为666</p>
</li>
<li><p>出于安全考虑，如何实现让别人ping不通你的在线的服务器。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; /<span class="keyword">proc</span>/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎样防止他人在服务器前通过按下 ctrl+alt+del 强行重启系统（提示，仔细看/etc/inittab）</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/init/control-alt-<span class="keyword">delete</span>.conf</span><br><span class="line"><span class="keyword">exec</span> /sbin/<span class="keyword">shutdown</span> -r now <span class="string">"Control-Alt-Delete pressed"</span>    这一项<span class="comment">#号注释掉，保存退出；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当在对服务器进行大负荷操作的时候，你不希望现在有普通用户登录上来，你该怎么做？不能剪网线。<br>touch /etc/nologin<br>创建一个nologin文件，此文件为特殊文件，创建之后所有普通用户不能登录；系统维护结束后删除此文件，用户可以恢复登录；只限于shell登录用户，本身shell为/sbin/nologin 的用户本身就无法登录shell，不受影响；</p>
</li>
<li>你新建了一批用户，出于安全考虑，要求这些用户在第一次登录的时候 就必须要更改密码，怎么实现？<br>修改/etc/shadow 第三列，新建用户的值更改为0.</li>
<li><p>如何把一个目录下的所有文件(不含目录)权限改为644？</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> ./ -<span class="built_in">type</span> f | xargs chmod <span class="number">644</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请实现下面这个需求：只允许使用普通账户登陆，而普通账户登录后，可以不输入密码就能sudo切换到root账户，root是不允许远程登录的。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sudoers</span><br><span class="line">添加一行<span class="keyword">user</span>    <span class="constant">A</span>LL=(<span class="literal">root</span>)    <span class="constant">N</span>OPASSWD: /bin/su</span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="constant">Permit</span>RootLogin 设置为no，禁止<span class="literal">root</span>远程登录；</span><br><span class="line"><span class="keyword">service</span> sshd <span class="literal">restart</span>    重启sshd服务生效；</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何使文件只能写不能删除？ 如何使文件不能被删除、重命名、设定链接接、写入、新增数据？<br>chattr +a    只能写不能删除<br>chattr +i    不能删除，重命名，写入新增数据；</p>
</li>
<li>用ls 查看目录或者文件时，第二列的数值表示什么意思？如果一个目录的这列的值为3，那么这个3是如何得到的？<br>第二列数值表示有几个文件使用相同的inode；<br>如果一个目录的这列为3，我们可以通过使用 ls -al dir/ |grep &#39;^d&#39;|wc -l 这条命令得到；<br><a href="http://www.linuxidc.com/Linux/2015-04/116337.htm" target="_blank" rel="external">来源</a></li>
</ol>
<h1 id="面试题">面试题</h1><ol>
<li>如何查看当前的Linux服务器的运行级别？<br>答: ‘who -r’ 和 ‘runlevel’ 命令可以用来查看当前的Linux服务器的运行级别。</li>
<li>如何查看Linux的默认网关？<br>答: 用 “route -n” 和 “netstat -nr” 命令，我们可以查看默认网关。除了默认的网关信息，这两个命令还可以显示当前的路由表。</li>
<li>如何在Linux上重建初始化内存盘镜像文件？<br>答: 在CentOS 5.X / RHEL 5.X中，可以用mkinitrd命令来创建初始化内存盘文件，举例如下：<h1 id="mkinitrd_-f_-v_/boot/initrd-$(uname_-r)-img_$(uname_-r)">mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r)</h1>如果你想要给特定的内核版本创建初始化内存盘，你就用所需的内核名替换掉 ‘uname -r’ 。<br>在CentOS 6.X / RHEL 6.X中，则用dracut命令来创建初始化内存盘文件，举例如下：<h1 id="dracut_-f">dracut -f</h1>以上命令能给当前的系统版本创建初始化内存盘，给特定的内核版本重建初始化内存盘文件则使用以下命令：<h1 id="dracut_-f_initramfs-2-x-xx-xx-el6-x86_64-img_2-x-xx-xx-el6-x86_64">dracut -f initramfs-2.x.xx-xx.el6.x86_64.img 2.x.xx-xx.el6.x86_64</h1></li>
<li>cpio命令是什么？<br>答: cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表，还可以从中提取文件。</li>
<li>patch命令是什么？如何使用？<br>答: 顾名思义，patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本。举个例子，Linux内核源代码由百万行代码文件构成，所以无论何时，任何代码贡献者贡献出代码，只需发送改动的部分而不是整个源代码，然后接收者用patch命令将改动写进原始的源代码里。<br>创建一个diff文件给patch使用，<h1 id="diff_-Naur_old_file_new_file_&gt;_diff_file">diff -Naur old_file new_file &gt; diff_file</h1>旧文件和新文件要么都是单个的文件要么都是包含文件的目录，-r参数支持目录树递归。<br>一旦diff文件创建好，我们就能在旧的文件上打上补丁，把它变成新文件：<h1 id="patch_&lt;_diff_file">patch &lt; diff_file</h1></li>
<li>aspell有什么用 ?<br>答: 顾名思义，aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序，并且作为一款免费替代品 ，最重要的是它非常好用。当aspell程序主要被其它一些需要拼写检查能力的程序所使用的时候，在命令行中作为一个独立运行的工具的它也能十分有效。</li>
<li>如何从命令行查看域SPF记录？<br>答: 我们可以用dig命令来查看域SPF记录。举例如下<br>linuxtechi@localhost:~$ dig -t TXT google.com</li>
<li>如何识别Linux系统中指定文件(/etc/fstab)的关联包？<br>答:<h1 id="rpm_-qf_/etc/fstab">rpm -qf /etc/fstab</h1>以上命令能列出提供“/etc/fstab”这个文件的包。</li>
<li>哪条命令用来查看bond0的状态？<br>答:<br>cat /proc/net/bonding/bond0</li>
<li>Linux系统中的/proc文件系统有什么用？<br>答: /proc文件系统是一个基于内存的文件系统，其维护着关于当前正在运行的内核状态信息，其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件，它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。</li>
<li>如何在/usr目录下找出大小超过10MB的文件？<br>答:<h1 id="find_/usr_-size_+10M">find /usr -size +10M</h1></li>
<li>如何在/home目录下找出120天之前被修改过的文件？<br>答:<h1 id="find_/home_-mtime_+120">find /home -mtime +120</h1></li>
<li>如何在/var目录下找出90天之内未被访问过的文件？<br>答:<h1 id="find_/var_!_-atime_-90">find /var ! -atime -90</h1></li>
<li>在整个目录树下查找文件“core”，如发现则无需提示直接删除它们。<br>答:<h1 id="find_/_-name_core_-exec_rm_{}_\;">find / -name core -exec rm {} \;</h1></li>
<li>strings命令有什么作用？<br>答: strings命令用来提取和显示非文本文件中的文本字符串。（LCTT 译注：当用来分析你系统上莫名其妙出现的二进制程序时，可以从中找到可疑的文件访问，对于追查入侵有用处）</li>
<li>tee 过滤器有什么作用 ?<br>答: tee 过滤器用来向多个目标发送输出内容。如果用于管道的话，它可以将输出复制一份到一个文件，并复制另外一份到屏幕上（或一些其它程序）。<br>linuxtechi@localhost:~$ ll /etc | nl | tee /tmp/ll.out<br>在以上例子中，从ll输出可以捕获到 /tmp/ll.out 文件中，并且同样在屏幕上显示了出来。</li>
<li>export PS1 = ”$LOGNAME@hostname:\$PWD: 这条命令是在做什么？<br>答: 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。</li>
<li>ll | awk ‘{print $3,”owns”,$9}’ 这条命令是在做什么？<br>答: 这条ll命令会显示这些文件的文件名和它们的拥有者。</li>
<li>:Linux中的at命令有什么用？<br>答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行。</li>
<li>linux中lspci命令的作用是什么？<br>答: lspci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v，-vv或-vvv来获取越来越详细的输出，加上-r参数的话，命令的输出则会更具有易读性。</li>
</ol>
<p><a href="http://www.linuxidc.com/Linux/2015-02/112637.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="上部">上部</h1><ol>
<li><p>如何更改linux主机名？<br>编辑配置文件 /etc/sysconfig/network<br>更改HOSTSNAME，保存退出后重启生效；</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="property">@yonglinux</span> ~]<span class="comment"># cat /etc/sysconfig/network</span></span><br><span class="line">NETWORKING=<span class="literal">yes</span></span><br><span class="line">HOSTNAME=yonglinux.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录linux，我们除了使用密码验证，还可以使用哪种方式？简述配置过程。<br>使用密钥加密登录，客户端生成公钥和私钥，客户端保存私钥，公钥复制到远程linux主机，登录时使用密钥加密登录；</p>]]>
    
    </summary>
    
      <category term="tests" scheme="http://tiandechi.com/tags/tests/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The advantages of Linux compile source code for installing package]]></title>
    <link href="http://tiandechi.com/2015/04/21/The-advantages-of-Linux-compile-source-code-for-installing-package/"/>
    <id>http://tiandechi.com/2015/04/21/The-advantages-of-Linux-compile-source-code-for-installing-package/</id>
    <published>2015-04-21T11:01:33.000Z</published>
    <updated>2015-04-21T05:00:54.000Z</updated>
    <content type="html"><![CDATA[<p>很多人放着最新的源码不用，等着有人帮他做出rpm,deb,才能安装。我说你为什么不用源码编译，这样版本比rpm高的多，有很多新功能，而没有烦人的依赖关系。可是他说：“要是我用源码编译安装，卸载的时候就不方便了，会留下很多垃圾。”<br><a id="more"></a><br>为什么程序还没有安装你就想到卸载？难道你不知道这个程序是用来做什么的？你应该改变到处找程序来试用的作法，而应该先了解一下到底那些程序有同样的功能，听听别人的意见，看看它们各有什么长处和短处，然后挑一个最适合你的程序来用。</p>
<p>从源码编译安装程序，不但比你装rpm更适合自己的机器设置，而且它们一般会装到/usr/local目录，这样你以后如果换硬盘重装系统，也可以把以前/usr/local下的程序原封不动拷贝过去用。我的/usr/local下有2G之多的程序，你想要是我有一台新机器要重新安装，然后配置，得花费多少时间？实际上我曾经通过网络把它们传到一台新机器上，然后就出去吃晚饭，回来时我就得到了另一台一摸一样的Linux机器。</p>
<p>确实要卸载makeinstall的程序怎么办呢？答案是直接删掉。别以为直接删掉程序会留下垃圾，引起“系统不稳定”。(btw:这是谁教你的啊？呵呵。)makeinstall无非就是把可执行程序放在/usr/local/bin,把某些函数库放在/usr/local/lib，把数据文件放在 /usr/local/share下一个它自己的目录，你把这些东西都删掉就行了，不会留下垃圾，即使真的留下一点文件没有删掉也占不了多少空间，更不可能引起系统不稳定。UNIX就是这么简单</p>
<p>但是有几个程序不建议从源码安装，它们是Mozilla,OpenOffice,...它们编译时会占用你几个G的空间和好几个小时的时间，这种花费我觉得是不值得的，因为你不能从编译得到更多好处，不如直接安装编译好的版本。</p>
<p><a href="http://blog.163.com/qiantu1986@126/blog/static/3592266920114172382031/" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很多人放着最新的源码不用，等着有人帮他做出rpm,deb,才能安装。我说你为什么不用源码编译，这样版本比rpm高的多，有很多新功能，而没有烦人的依赖关系。可是他说：“要是我用源码编译安装，卸载的时候就不方便了，会留下很多垃圾。”<br>]]>
    
    </summary>
    
      <category term="advantage" scheme="http://tiandechi.com/tags/advantage/"/>
    
      <category term="compile" scheme="http://tiandechi.com/tags/compile/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[the physical structure and IO process of the disk]]></title>
    <link href="http://tiandechi.com/2015/04/21/the-physical-structure-and-IO-process-of-the-disk/"/>
    <id>http://tiandechi.com/2015/04/21/the-physical-structure-and-IO-process-of-the-disk/</id>
    <published>2015-04-21T10:58:12.000Z</published>
    <updated>2015-04-21T04:59:56.000Z</updated>
    <content type="html"><![CDATA[<p>对于管理磁盘，分磁盘面、磁头、磁道、柱面和扇区。</p>
<pre><code>磁盘面：磁盘是由一叠磁盘面组成，见下左图。
磁头(Heads)：每个磁头对应一个磁盘面，负责该磁盘面上的数据的读写。
磁道(Track)：每个盘面会围绕圆心划分出多个同心圆圈，每个圆圈叫做一个磁道。
柱面(Cylinders)：所有盘片上的同一位置的磁道组成的立体叫做一个柱面。
扇区(Sector)：以磁道为单位管理磁盘仍然太大，所以计算机前辈们又把每个磁道划分出了多个扇区，见下图
![<span class="link_label">HDD physical structure</span>](<span class="link_url">http://ww4.sinaimg.cn/mw690/6e8d8f65gw1erbso6izmoj20ib08cq4d.jpg</span>)
</code></pre><a id="more"></a>
<p>Linux上可以通过fdisk命令，来查看当前系统使用的磁盘的这些物理信息。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="annotation">@dbserver</span> ~]# fdisk -l</span><br><span class="line">Disk <span class="regexp">/dev/</span><span class="string">sda:</span> <span class="number">1199.6</span> GB, <span class="number">1199638052864</span> bytes</span><br><span class="line"><span class="number">255</span> heads, <span class="number">63</span> sectors/track, <span class="number">145847</span> cylinders</span><br><span class="line">Units = cylinders of <span class="number">16065</span> * <span class="number">512</span> = <span class="number">8225280</span> bytes</span><br><span class="line">Sector size (logical<span class="regexp">/physical): 512 bytes /</span> <span class="number">512</span> bytes</span><br><span class="line">I<span class="regexp">/O size (minimum/</span>optimal): <span class="number">512</span> bytes / <span class="number">512</span> bytes</span><br><span class="line">Disk <span class="string">identifier:</span> <span class="number">0x54ab02ca</span></span><br><span class="line">Device Boot      Start        End      Blocks  Id  System</span><br><span class="line"><span class="regexp">/dev/</span>sda1              <span class="number">1</span>          <span class="number">5</span>      <span class="number">40131</span>  de  Dell Utility</span><br><span class="line">Partition <span class="number">1</span> does not end on cylinder boundary.</span><br><span class="line"><span class="regexp">/dev/</span>sda2  *          <span class="number">6</span>        <span class="number">267</span>    <span class="number">2097152</span>    c  W95 FAT32 (LBA)</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>可以看出我的磁盘有255个heads，也就是说共有255个盘面。145847 个cylinders，也就是说每个盘面上都有145847 个磁道， 63sectors/track说的是每个磁道上共有63个扇区。命令结果也给出了Sector size的值是512bytes。那我们动笔算一下该磁盘的大小。<br>255盘面  <em> 145847 柱面 </em> 63扇区 * 每个扇区512bytes =1199632412160 byte=1117.25GB<br>结果是1117.25GB,和磁盘的总大小相符。<br>在如上图可以发现一个错误（标红），是即/dev/sda1的start位置从第 1 扇区个删除开始，如果将第0至62个扇区,即第一磁道（cylinders）单独留给磁盘MBR并从第64个扇区，即第二个磁道（cylinders）开始分区，将会对文件系统的性能会带来很大的提升。</p>
<p>接下来让我们在了解一下磁盘IO时的过程。</p>
<ol>
<li>首先是磁头径向移动来寻找数据所在的磁道。这部分时间叫寻道时间。</li>
<li>找到目标磁道后通过盘面旋转，将目标扇区移动到磁头的正下方。</li>
<li>向目标扇区读取或者写入数据。到此为止，一次磁盘IO完成。</li>
</ol>
<p>故：单次磁盘IO时间 = 寻道时间 + 旋转延迟 + 存取时间。<br>对于旋转延时，现在主流服务器上经常使用的是1W转/分钟的磁盘，每旋转一周所需的时间为60*1000/10000=6ms，故其旋转延迟为（0-6ms）。对于存取时间，一般耗时较短，为零点几ms。对于寻道时间，现代磁盘大概在3-15ms，其中寻道时间大小主要受磁头当前所在位置和目标磁道所在位置相对距离的影响。</p>
<pre><code>操作系统通过按磁道对应的柱面划分分区，来降低磁盘IO所花费的的寻道时间 ，进而提高磁盘的读写性能。
</code></pre><hr>
<p>实际上，上面这段话还是存在问题的，分区对性能的提高几乎为0，我在 V2EX 有讨论： <a href="http://www.v2ex.com/t/184874" target="_blank" rel="external">分区能提高硬盘的读写性能？</a></p>
<p><a href="http://www.linuxidc.com/Linux/2015-04/116419.htm" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于管理磁盘，分磁盘面、磁头、磁道、柱面和扇区。</p>
<pre><code>磁盘面：磁盘是由一叠磁盘面组成，见下左图。
磁头(Heads)：每个磁头对应一个磁盘面，负责该磁盘面上的数据的读写。
磁道(Track)：每个盘面会围绕圆心划分出多个同心圆圈，每个圆圈叫做一个磁道。
柱面(Cylinders)：所有盘片上的同一位置的磁道组成的立体叫做一个柱面。
扇区(Sector)：以磁道为单位管理磁盘仍然太大，所以计算机前辈们又把每个磁道划分出了多个扇区，见下图
![<span class="link_label">HDD physical structure</span>](<span class="link_url">http://ww4.sinaimg.cn/mw690/6e8d8f65gw1erbso6izmoj20ib08cq4d.jpg</span>)
</code></pre>]]>
    
    </summary>
    
      <category term="Disk" scheme="http://tiandechi.com/tags/Disk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VSFTP server configure]]></title>
    <link href="http://tiandechi.com/2015/04/19/VSFTP-server-configure/"/>
    <id>http://tiandechi.com/2015/04/19/VSFTP-server-configure/</id>
    <published>2015-04-19T08:19:25.000Z</published>
    <updated>2015-04-19T01:55:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Linux_FTP服务器分类：">Linux FTP服务器分类：</h1><ol>
<li>wu-ftp</li>
<li>proftp=profession ftp</li>
<li>vsftp=very security ftp</li>
</ol>
<p>配置文件：<br>    /etc/vsftpd/vsftpd.conf   //主配置文件</p>
<pre><code>/etc/vsftpd<span class="class">.ftpusers</span>      <span class="comment">//被禁止登录FTP的用户文件</span>

/etc/vsftpd<span class="class">.user_list</span>     <span class="comment">//允许登录FTP的用户文件</span>
</code></pre><h1 id="访问方式">访问方式</h1><ol>
<li>匿名登录</li>
<li>帐号登录</li>
</ol>
<a id="more"></a>
<h1 id="启动FTP服务器：">启动FTP服务器：</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#service vsftpd restart</span><br></pre></td></tr></table></figure>
<h1 id="配置vsftp服务器">配置vsftp服务器</h1><ol>
<li><p>vsftpd.conf各项参数说明：</p>
<pre><code><span class="comment">#vi /etc/vsftpd/vsftpd.conf</span>

<span class="variable">&lt;1&gt;</span>第7行： 控制匿名登录

            anonymous_enable=YES 改成NO

<span class="variable">&lt;2&gt;</span>第10行：允许本地帐号登录

<span class="variable">&lt;3&gt;</span>第13行：控制可写权限

<span class="variable">&lt;4&gt;</span>第17行：控制本地文件的权限掩码

<span class="variable">&lt;5&gt;</span>第22行：控制是否允许匿名上传(与26行同时开启或关闭)

<span class="variable">&lt;6&gt;</span>第26行：控制是否允许匿名写及创建目录的权限

<span class="variable">&lt;7&gt;</span>第33行：控制上传或下载的日志记录

<span class="variable">&lt;8&gt;</span>第46行：控制日志的保存路径

<span class="variable">&lt;9&gt;</span>第52行：设置指令超时的时间，默认为600秒

<span class="variable">&lt;10&gt;</span>第55行：设置数据连接的超时时间，默认为120秒

<span class="variable">&lt;11&gt;</span>第91行：控制登录FTP的用户是否被限制在家目录下;(必须与93行同时开启或关闭)

            chroot_list_enable=YES

<span class="variable">&lt;12&gt;</span>第93行：登录FTP后被限制在家目录下的用户列表文件

            chroot_list_file=/etc/vsftpd.chroot_list

            在/etc目录下新建一个vsftpd.chroot_list文件，内容加入要限制用户的用户名

            没加入限制用户可以访问其目录

<span class="variable">&lt;13&gt;</span>第99行：控制登录FTP后是否允许ls命令

<span class="variable">&lt;14&gt;</span>第102行:启用/etc/vsftpd.user_list文件
</code></pre></li>
<li><p>配置匿名登录</p>
<pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

第<span class="number">7</span>行，设置为： (默认值)

anonymous_enable=YES

启动vsftpd服务器：

<span class="id">#service</span> vsftpd restart

<span class="id">#service</span> iptables stop

匿名登录的默认目录：

/var/ftp/pub

打开匿名上传和写权限：

<span class="id">#vi</span> /etc/vsftpd/vsftp<span class="class">.conf</span>

激活第<span class="number">22</span>行

激活第<span class="number">26</span>行

打开默认共享目录的权限

<span class="id">#chmod</span> <span class="number">777</span> /var/ftp/pub

备注：匿名可以上传下载，但不能删除；
</code></pre></li>
<li><p>本地帐号登录</p>
<pre><code>&lt;<span class="number">1</span>&gt;禁用匿名登入

修改配置文件

<span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

禁用所有匿名控制行,如：

   禁用第<span class="number">7</span>行，第<span class="number">22</span>行，第<span class="number">26</span>行；

&lt;<span class="number">2</span>&gt;开放那些用户可以登入和那些用户拒绝登入

<span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

    在<span class="number">102</span>行后，插入如下：

    userlist_deny=NO

       (备注：设置/etc/vsftpd.user_list文件中的用户可登录FTP)

    保存退出

   如果是#userlist_deny=NO 注释掉，则默认全部用户可以登入FTP,当要限某用户不能登入：

    把用户名加入这个文件当中/etc/vsftpd.ftpusers，则这个用户名拒绝登入FTP

     创建用户并加入到相应的控制文件中

      <span class="id">#useradd</span> us1

<span class="id">#useradd</span> us2

      <span class="id">#passwd</span> us1

      <span class="id">#passwd</span> us2

     允许登录到FTP的用户：

      <span class="id">#echo</span> us1&gt;&gt;/etc/vsftpd<span class="class">.user_list</span>

      <span class="id">#echo</span> us2&gt;&gt;/etc/vsftpd<span class="class">.user_list</span>   
</code></pre></li>
</ol>
<h1 id="启动FTP服务器：-1">启动FTP服务器：</h1><pre><code><span class="id">#service</span> vsftpd restart

备注：帐号登录FTP，默认是登录在家目录下；

禁止登录到FTP的用户：

<span class="id">#echo</span> us3&gt;&gt;/etc/vsftpd.ftpusers
</code></pre><h1 id="将登录后的用户限制在本地家目录下：">将登录后的用户限制在本地家目录下：</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

激活第<span class="number">91</span>行及第<span class="number">93</span>行

   chroot_list_enable=YES

   chroot_list_file=/etc/vsftpd<span class="class">.chroot_list</span>


新建受限用户的列表文件并加入受限用户名

<span class="id">#vi</span> /etc/vsftpd<span class="class">.chroot_list</span>

  us2

保存退出

<span class="id">#service</span> vsftpd restart
</code></pre><h1 id="限制匿名上传的速度：">限制匿名上传的速度：</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

:$

anon_max_rate=<span class="number">5000</span> <span class="comment">//默认以字节为单位 5000表示5K速度</span>
</code></pre><h1 id="限制本地帐号的上传速度：">限制本地帐号的上传速度：</h1><pre><code>local_max_rate=<span class="number">5000</span> <span class="comment">//以(字节/秒)为单位</span>
</code></pre><h1 id="针对不同的使用者限制不同的速度(这个速度优先限制所有用户的速度）:">针对不同的使用者限制不同的速度(这个速度优先限制所有用户的速度）:</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>   增加下面一行

user_config_dir=/etc/vsftpd/userconf

<span class="id">#mkdir</span> /etc/vsftpd/userconf   创建一个目录

<span class="id">#vi</span> /etc/vsftpd/userconf/user1   （user1是要限制速度的用户名)

local_max_rate=<span class="number">25000</span>
</code></pre><h1 id="定制欢迎信息：">定制欢迎信息：</h1><pre><code><span class="id">#vi</span> /etc/vsftpd/vsftpd<span class="class">.conf</span>

激活<span class="number">80</span>行

ftpd_banner=Welcome to Huayu FTP service.
</code></pre><h1 id="限制服务器连接数和同IP连接数">限制服务器连接数和同IP连接数</h1><ol>
<li>max_clients<br>可使用这个参数定义最大的总联机数。超过这个数目将会拒绝联机，0 表示不限。默认值为0。</li>
<li>max_per_ip<br>使用这个参数定义每个ip address 所可以联机的数目。超过这个数目将会拒绝联机，0 表示不限。默认值为0</li>
</ol>
<h1 id="虚拟FTP用户设置">虚拟FTP用户设置</h1><ol>
<li><p>建立虚拟用户口令库文件</p>
<pre><code><span class="id">#vi</span> /etc/vsftpd/logins<span class="class">.txt</span>

vuser1

<span class="number">123</span>

vuser2

<span class="number">321</span>

:wq

口令库文件中奇数行设置用户名，偶数行设置口令
</code></pre></li>
<li>生成vsftpd的认证文件<pre><code><span class="id">#db_load</span> -T -t hash -f /etc/vsftpd/logins<span class="class">.txt</span> /etc/vsftpd/vsftpd_login<span class="class">.db</span> ##生成认证文件
</code></pre></li>
<li>设置认证文件只对root用户可读可写<pre><code><span class="preprocessor"># chmod 600 /etc/vsftpd/vsftpd_login.db</span>
</code></pre></li>
<li>建立虚拟用户所需的PAM配置文件，手工建立vsftpd.vu文件<pre><code># cat <span class="regexp">/etc/</span>pam.d/vsftpd.vu
auth required <span class="regexp">/lib/</span>security<span class="regexp">/pam_userdb.so db=/</span>etc<span class="regexp">/vsftpd/</span>vsftpd_login
account required <span class="regexp">/lib/</span>security<span class="regexp">/pam_userdb.so db=/</span>etc<span class="regexp">/vsftpd/</span>vsftpd_login
</code></pre></li>
<li>建立所有FTP虚拟用户帐号使用的系统用户帐号，并设置该帐号宿主目录的权限<pre><code><span class="preprocessor"># useradd -d /home -s /sbin/nologin /ftpsite virtual</span>
<span class="preprocessor"># chmod 700 /home/ftpsite</span>
</code></pre></li>
<li><p>设置vsftpd.conf配置文件</p>
<pre><code><span class="comment">#vi /etc/vsftpd/vsftpd.conf</span>

在配置文件中添加虚拟用户的配置内容

<span class="constant">guest_enable</span>=YES

<span class="constant">guest_username</span>=virtual

<span class="constant">pam_service_name</span>=vsftpd.vu（要和刚才建的PAM文件对应）

<span class="constant">user_config_dir</span>=/etc/vsftpd/user_config_dir （指定每个虚拟用户账号配置目录，）
<span class="constant">local_root</span>=/www （这行没有，虚拟用户登入到/ftpsite）
</code></pre></li>
<li><p>配置虚拟用户名的设置</p>
<pre><code><span class="comment">#mkdir -p /etc/vsftpd/user_config_dir （主配置文件对应）</span>
<span class="comment">#mkdir -p /www/vuser1    （创建虚拟用主目录）</span>
<span class="comment">#chmod -R 777 /www/vuser1 （设定权限）</span>

<span class="comment">#touch /etc/vsftpd/user_config_dir/vuser1 (为vuser1权限配置文件)</span>
<span class="comment">#echo "anon_world_readable_only=NO</span>
write_<span class="built_in">enable</span>=YES
anon_upload_<span class="built_in">enable</span>=YES
anon_other_write_<span class="built_in">enable</span>=YES
<span class="built_in">local</span>_root=/www/feixiang
anon_mkdir_write_<span class="built_in">enable</span>=YES<span class="string">" &gt;/etc/vsftpd/user_config_dir/vuser1</span>
</code></pre></li>
<li><p>重新启动vsftpd服务程序</p>
<pre><code><span class="preprocessor"># service vsftpd restart</span>

现在就应该可以用虚拟帐号登陆了.
</code></pre></li>
</ol>
<p><a href="http://www.cnblogs.com/JemBai/archive/2009/02/05/1384413.html" target="_blank" rel="external">Linux VSFTP服务器详细配置</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Linux_FTP服务器分类：">Linux FTP服务器分类：</h1><ol>
<li>wu-ftp</li>
<li>proftp=profession ftp</li>
<li>vsftp=very security ftp</li>
</ol>
<p>配置文件：<br>    /etc/vsftpd/vsftpd.conf   //主配置文件</p>
<pre><code>/etc/vsftpd<span class="class">.ftpusers</span>      <span class="comment">//被禁止登录FTP的用户文件</span>

/etc/vsftpd<span class="class">.user_list</span>     <span class="comment">//允许登录FTP的用户文件</span>
</code></pre><h1 id="访问方式">访问方式</h1><ol>
<li>匿名登录</li>
<li>帐号登录</li>
</ol>]]>
    
    </summary>
    
      <category term="VSFTP" scheme="http://tiandechi.com/tags/VSFTP/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenSSH management:ssh-agent & keychain]]></title>
    <link href="http://tiandechi.com/2015/04/19/OpenSSH-management-ssh-agent-and-keychain/"/>
    <id>http://tiandechi.com/2015/04/19/OpenSSH-management-ssh-agent-and-keychain/</id>
    <published>2015-04-19T08:12:38.000Z</published>
    <updated>2015-04-19T01:27:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="介绍_ssh-agent">介绍 ssh-agent</h1><p>ssh-agent 是专为既令人愉快又安全的处理 RSA 和 DSA 密钥而设计的特殊程序，它包括在OpenSSH分发内(请参阅 本系列文章的第 1 部分以得到关于 RSA 和 DSA 认证的介绍)。不同于 ssh ， ssh-agent 是个长时间持续运行的守护进程(daemon)，设计它的唯一目的就是对解密的专用密钥进行高速缓存。</p>
<p>ssh 包含的内建支持允许它同 ssh-agent 通信，允许 ssh 不必每次新连接时都提示您要密码才能获取解密的专用密钥。对于 ssh-agent ，您只要使用 ssh-add 把专用密钥添加到 ssh-agent 的高速缓存中。这是个一次性过程;用过 ssh-add 之后， ssh 将从 ssh-agent 获取您的专用密钥，而不会提示要密码短语来烦您了。</p>
<h1 id="使用_ssh-agent">使用 ssh-agent</h1><a id="more"></a>
<p>让我们看一下整个 ssh-agent 密钥高速缓存系统的工作过程。 ssh-agent 启动时，在脱离 shell(外壳程序)并继续在后台运行之前它会输出一些重要的环境变量。以下是 ssh-agent 开始时生成的输出的一些示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% ssh-agent</span><br><span class="line"></span><br><span class="line">SSH_AUTH_SOCK=/tmp/ssh-XX4LkMJS/agent.<span class="number">26916</span>; <span class="built_in">export</span> SSH_AUTH_SOCK;</span><br><span class="line"></span><br><span class="line">SSH_AGENT_PID=<span class="number">26917</span>; <span class="built_in">export</span> SSH_AGENT_PID;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> Agent pid <span class="number">26917</span>;</span><br></pre></td></tr></table></figure></p>
<p>正如您所看到的，事实上 ssh-agent 的输出是一系列 bash 命令;如果这些命令被执行，则将设置两个环境变量：SSH_AUTH_SOCK 和 SSH_AGENT_PID。内含的 export 命令使这些环境变量对之后运行的任何附加命令都可用。唔， 如果 shell 真对这些行进行计算，这一切才会发生，但是此时它们只是被打印到标准输出(stdout)而已。要使之确定，我们可以象下面这样调用 ssh-agent ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">`ssh-agent`</span></span><br></pre></td></tr></table></figure></p>
<p>这个命令先让 bash 运行 ssh-agent 后对 ssh-agent 的输出进行计算。shell 以这种调用方式(使用反引号，而不是普通的单引号)设置并导出 SSH_AGENT_PID 及 SSH_AUTH_SOCK 变量，使这些变量对于您在登录会话期间启动的所有新进程都可用。</p>
<p>启动 ssh-agent 的最佳方式就是把上面这行添加到您的 ~/.bash_profile 中;这样，在您的登录 shell 中启动的所有程序都将看到环境变量，而且能够定位 ssh-agent ，并在需要的时候向其查询密钥。尤其重要的环境变量是 SSH_AUTH_SOCK;SSH_AUTH_SOCK 包含有 ssh 和 scp 可以用来同 ssh-agent 建立对话的 UNIX 域套接字的路径。</p>
<h1 id="使用_ssh-add">使用 ssh-add</h1><p>但是 ssh-agent 启动时高速缓存当然是空的，里面不会有解密的专用密钥。在我们真能使用 ssh-agent 之前，首先还需要使用 ssh-add 命令把我们的专用密钥添加到 ssh-agent 的高速缓存中。下面的示例中，我使用 ssh-add 把我的 ~/.ssh/identity 专用 RSA 密钥添加到 ssh-agent 的高速缓存中：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ssh-add ~<span class="regexp">/.ssh/i</span>dentity</span><br><span class="line"></span><br><span class="line">Need passphrase <span class="keyword">for</span> <span class="regexp">/home/</span>drobbins<span class="regexp">/.ssh/i</span>dentity</span><br><span class="line"></span><br><span class="line">Enter passphrase <span class="keyword">for</span> <span class="regexp">/home/</span>drobbins<span class="regexp">/.ssh/i</span>dentity</span><br><span class="line"></span><br><span class="line">(enter passphrase)</span><br></pre></td></tr></table></figure></p>
<p>正如您所看到的， ssh-add 要我的密码短语来对专用密钥进行解密并存储在 ssh-agent 的高速缓存中以备使用。一旦您已经用 ssh-add 把专用密钥(或多个密钥)添加到 ssh-agent 的高速缓存中， 并在当前的 shell 中(如果您在 ~/.bash_profile 中启动 ssh-agent ，情况应当是这样)定义 SSH_AUTH_SOCK，那么您可以使用 scp 和 ssh 同远程系统建立连接而不必提供密码短语。</p>
<h1 id="ssh-agent_的不足之处">ssh-agent 的不足之处</h1><p>ssh-agent 确实棒，但是其缺省配置还是会留给我们一些小小的不便。让我们来看一下这些不足吧。</p>
<p>首先，~/.bash_profile 中的 eval <code>ssh-agent</code> 使每次登录会话都会启动一个新的 ssh-agent 副本;这不仅仅是有一丁点儿浪费，而且还意味着您得使用 ssh-add 向每个新的 ssh-agent 副本添加专用密钥。如果您只想打开系统上的一个终端或控制台，这没什么大不了的，但是我们中大多数人打开相当多的终端，每次新打开控制台都需要键入密码短语。从技术角度讲，既然一个 ssh-agent 进程的确应当足够了，要是我们还需这样做，这毫无道理。</p>
<p>有关 ssh-agent 的缺省设置的另外一个问题是它同 cron 作业不兼容。由于 cron 作业是 cron 进程启动的，这些作业无法从它们的环境中继承 SSH_AUTH_SOCK 变量，因而也无从知道 ssh-agent 进程正在运行以及如何同它联系。事实证明这个问题也是可以修补的。</p>
<h1 id="开始用到_keychain">开始用到 keychain</h1><p>为了解决这些问题，我编写了一个有用的 ssh-agent 前端，它基于 bash，叫做 keychain 。 keychain 的特别之处在于它允许 每个系统使用一个 ssh-agent 进程，而非每次登录会话。这意味着您只需对每个专用密钥执行一次 ssh-add ，就一次。正如我们稍后将要看到的一样， keychain 甚至有助于优化 ssh-add ，而这只要它试图向那些正在运行的 ssh-agent 添加其高速缓存中没有的专用密钥。</p>
<p>以下对 keychain 如何工作从头到尾浏览一遍。从 ~/.bash_profile 中启动时， keychain 将首先查看 ssh-agent 是否已经在运行了。如果没有，它就启动 ssh-agent 并把重要的 SSH_AUTH_SOCK 和 SSH_AGENT_PID 变量记录在 ~/.ssh-agent 文件中，一方面为了安全而保存，另一方面也是为了以后的使用。这是启动 keychain 的最佳途径;同使用平淡无奇的老式 ssh-agent 一样，我们在 ~/.bash_profile 内部执行必要的配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment">#example ~/.bash_profile file</span></span><br><span class="line"></span><br><span class="line">/usr/bin/keychain ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment">#redirect ~/.ssh-agent output to /dev/null to zap the annoying</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#"Agent PID" message</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.ssh-agent &gt; /dev/null</span><br></pre></td></tr></table></figure></p>
<p>正如您所看到的，对于 keychain 我们用 source 命令读入并执行 ~/.ssh-agent 文件，而不是象我们直接使用 ssh-agent 时所做的对输出进行计算。但是，结果是一样的：定义了非常重要的 SSH_AUTH_SOCK，而且正运行 ssh-agent 以备使用。同时，因为 SSH_AUTH_SOCK 被记录在 ~/.ssh-agent 里，只要用 source 命令读入并执行 ~/.ssh-agent 文件，就可以轻易的把我们的 shell 脚本及 cron 作业同 ssh-agent 连接起来。 keychain 本身也利用了这个文件;您应该记住 keychain 启动时，它会查看现有的 ssh-agent 是否正在运行。如果是，则它使用 ~/.ssh-agent 文件来获得适当的 SSH_AUTH_SOCK 设置，这样就使 keychain 能使用现有的代理程序而不必新启动一个。只有在 ~/.ssh-agent 文件无效(指向一个不存在的 ssh-agent )或 ~/.ssh-agent 文件本身不存在时， keychain 才会启动新的 ssh-agent 进程。</p>
<h1 id="安装_keychain">安装 keychain</h1><p>安装 keychain 很容易。首先，直接到 keychain 工程主页下载可用的 keychain 源压缩文档的最新版本。然后，安装如下：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># tar xzvf keychain-1.0.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># cd keychain-1.0</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># install -m0755 keychain /usr/bin</span></span><br></pre></td></tr></table></figure></p>
<p>既然 keychain 在 /usr/bin/ 目录下，就请把它添加到您的 ~/.bash_profile 中，并把您的专用密钥路径作为参数。下面是一个既标准又好的启用 keychain 的 ~/.bash_profile：</p>
<p>启用 keychain 的 ~/.bash_profile 示例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment">#on this next line, we start keychain and point it to the private keys that</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#we'd like it to cache</span></span><br><span class="line"></span><br><span class="line">/usr/bin/keychain ~/.ssh/id_rsa ~/.ssh/id_dsa</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.ssh-agent &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment">#sourcing ~/.bashrc is a good thing</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h1 id="Keychain_生效">Keychain 生效</h1><p>您一为每次登录时调用 keychain 配置好了 ~/.bash_profile，就请先退出再登录回来。在您再次登录时， keychain 将启动 ssh-agent ，并记录下 ~/.ssh-agent 中的代理程序环境变量设置，然后提示您输入在 ~/.bash_profile 中的 keychain 命令行指定的所有专用密钥的密码短语：</p>
<p>Keychain 首次启动</p>
<p><em>图片丢失</em></p>
<p>您一输入密码短语，您的专用密钥就会被高速缓存，同时 keychain 将退出。接着，用 source 命令读入并执行 ~/.ssh-agent，初始化您的登录会话以便同 ssh-agent 一起使用。现在，如果您退出，然后再登录回来，将发现 keychain 会找到现有的 ssh-agent 进程;在您退出时，它并没有终止。此外， keychain 将验证您指定的专用密钥是否已经在 ssh-agent 的高速缓存中了。如果没有，那么将会提示您输入正确的密码短语，但如果一切进展顺利，则现有 ssh-agent 仍包含有您以前添加的专用密钥;这意味着不会提示您输入密码：</p>
<p>Keychain 找到现有的 ssh-agent</p>
<p><em>图片丢失</em></p>
<p>祝贺您!您刚才已经登录了，应该能够用 ssh 和 scp 连到远程系统;您不必一登录就使用 ssh-add ，而且 ssh 和 scp 也不会提示您输入密码短语。事实上，只要初始的 ssh-agent 进程一直在运行，您就能不提供密码登录并建立 ssh 连接。 ssh-agent 进程持续运行直到机器重新启动也是很有可能的;由于您最可能在 Linux 系统上这样设置，所以也许一连几个月您都不必输入密码短语!欢迎来到安全的、使用 RSA 和 DSA 认证无密码连接的世界。</p>
<p>继续创建几个新的登录会话，您会发现每次 keychain 都会准确无误的“钩住”到同一 ssh-agent 进程。不要忘记您也可以使 cron 作业和脚本“钩住”正在运行的 ssh-agent 进程。要在 shell 脚本和 cron 作业中使用 ssh 或 scp 命令，只要确保先用 source 命令读入并执行 ~/.ssh-agent：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.ssh-agent</span><br></pre></td></tr></table></figure></p>
<p>然后，随后所有的 ssh 或 scp 命令就能够找到当前正在运行的 ssh-agent ，并且象您在 shell 中一样能建立安全的无密码连接。</p>
<p>＃ Keychain 选项</p>
<p>您启动并运行 keychain 后，一定要键入 keychain --help 以熟悉 keychain 所有的命令行选项。我们要特别看一下这个选项： -clear 选项。</p>
<p>还记得我在第 1 部分里阐释了使用不加密专用密钥是一种危险的做法，因为这种做法允许其它人盗用您的专用密钥不提供密码就可以从所有系统登录到您的远程帐户。唔，尽管 keychain 不易遭到这种滥用(只要您使用加密的专用密钥就行)，但仍存在有可能可以利用的弱点，同 keychain 使得“钩住”长时间持续运行的 ssh-agent 进程如此容易这一事实直接相关。我想，如果闯入者以某种方式能想出我的密码或密码短语，还能登录进入我的本地系统，会发生什么事情呢?如果出于某种原因他们能以我的用户名登录，那么 keychain 就会立刻授权他们访问我的解密的专用密钥，使他们可以轻而易举的访问我的其它帐户。</p>
<p>现在，在继续下面的内容之前，让我们先客观的表述一下安全威胁。如果由于某种原因一些恶意的用户能以我的身份登录， keychain 确实会允许他们访问我的远程帐户。但，尽管如此，这位闯入者要偷到我的加密的专用密钥非常困难，因为它们仍旧在磁盘上保持着加密状态。而且，得到我的专用密钥访问权要求用户真的以我的身份 登录，不单单是阅读我的目录中的文件而已。因此，滥用 ssh-agent 是比只偷到一个不加密的专用密钥困难得多的一项任务，后者只需要闯入者通过某种手段获得我在 ~/.ssh 里的文件的访问权，而不管是否是以我的身份登录。不过，如果闯入者能够成功的以我的身份登录，通过使用我的加密专用密钥他们造成相当多的额外损害。所以，如果您刚好在您不频繁登录或没有对安全缺口进行密切监视的一台服务器上使用 keychain ，那么请您考虑使用 --clear 选项以提供附加的安全层。</p>
<p>--clear 选项允许您让 keychain 假定把每次以您的帐户的新登录都当作是可能的安全缺口，直到能证明并非如此。当您启动 keychain 时使用了 --clear 选项时，您登录的时候 keychain 会立即刷新 ssh-agent 的高速缓存里的所有专用密钥，此后才执行它的常规职责。这样，如果您是一位闯入者，则 keychain 会提示您输入密码短语而不会让您访问现有的高速缓存中的密钥集合。但是，虽然这样增强了安全性，却使情况有点更不方便，尤其好象完全是 ssh-agent 在运行，而 keychain 并没有运行。此处，情况常常是这样，一个人可以选择或者安全性更高，或更方便，但不能两者兼得。</p>
<p>尽管如此，使用带有 --clear 的 keychain 仍然比只用 ssh-agent 要好;请记住，当您使用 keychain --clear 时，您的 cron 作业和脚本仍然能建立无密码连接;这是因为专用密钥是在 登录时刷新，而不是在 退出时。由于从系统退出不会构成潜在的安全缺口，因而没有理由要 keychain 来刷新 ssh-agent 的密钥作为响应。因此，对于不频繁访问又需要偶而执行安全拷贝任务的服务器而言，比如，备份服务器、防火墙及路由器， --clear 选项是一个理想的选择。</p>
<p><a href="http://sec.chinabyte.com/459/8607459.shtml" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="介绍_ssh-agent">介绍 ssh-agent</h1><p>ssh-agent 是专为既令人愉快又安全的处理 RSA 和 DSA 密钥而设计的特殊程序，它包括在OpenSSH分发内(请参阅 本系列文章的第 1 部分以得到关于 RSA 和 DSA 认证的介绍)。不同于 ssh ， ssh-agent 是个长时间持续运行的守护进程(daemon)，设计它的唯一目的就是对解密的专用密钥进行高速缓存。</p>
<p>ssh 包含的内建支持允许它同 ssh-agent 通信，允许 ssh 不必每次新连接时都提示您要密码才能获取解密的专用密钥。对于 ssh-agent ，您只要使用 ssh-add 把专用密钥添加到 ssh-agent 的高速缓存中。这是个一次性过程;用过 ssh-add 之后， ssh 将从 ssh-agent 获取您的专用密钥，而不会提示要密码短语来烦您了。</p>
<h1 id="使用_ssh-agent">使用 ssh-agent</h1>]]>
    
    </summary>
    
      <category term="SSH" scheme="http://tiandechi.com/tags/SSH/"/>
    
      <category term="keychain" scheme="http://tiandechi.com/tags/keychain/"/>
    
      <category term="ssh-agent" scheme="http://tiandechi.com/tags/ssh-agent/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[about Chrome]]></title>
    <link href="http://tiandechi.com/2015/04/18/about-Chrome/"/>
    <id>http://tiandechi.com/2015/04/18/about-Chrome/</id>
    <published>2015-04-18T15:57:31.000Z</published>
    <updated>2015-04-18T08:00:10.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>离线版 Chrome下载方法<br> <a href="http://dl.google.com/chrome/install/[版本号后两位]/chrome_installer.exe" target="_blank" rel="external">http://dl.google.com/chrome/install/[版本号后两位]/chrome_installer.exe</a><br> 要想下载离线版 Chrome，必须知道你要下载的版本号，取版本号第二个小数点后的数字串。如 Version 27.0.1453.94 m 的下载地址就是：<br> <a href="http://dl.google.com/chrome/install/1453.94/chrome_installer.exe" target="_blank" rel="external">http://dl.google.com/chrome/install/1453.94/chrome_installer.exe</a><br> 注：离线版 Chrome 可能不会自动更新。</li>
<li>Chrome 版本号规则<br> Google Chrome 版本号的命名规则，拿最新的 Chrome 27.0.1453.94 为例，这个版本号可以分成 3 部分：<br> 27.0 —— 这是主版本号。<br> .1453 —— 这是一个版本代码，通常它的变化意味着有新的功能的加入。<br> .94 —— 这是用于修补漏洞和稳定性调整更新时候用到的数字。通常没有新功能加入的时候这个数字会实时更新。</li>
</ol>
<p><a href="http://m.baidu.com/from=844b/bd_page_type=1/ssid=0/uid=0/pu=usm%400%2Csz%401320_2001%2Cta%40iphone_1_4.3_3_533/baiduid=23B649E6AA04C1D3B1BFCE13CE554FCE/w=0_10_chromium+he+chrome/t=iphone/l=3/tc?ref=www_iphone&amp;lid=6928532657601785428&amp;order=2&amp;vit=osres&amp;tj=www_normal_2_0_10_title&amp;m=8&amp;srd=1&amp;cltj=cloud_title&amp;dict=32&amp;fm=wnor&amp;sec=409&amp;di=19550545459566e7&amp;bdenc=1&amp;nsrc=IlPT2AEptyoA_yixCFOxXnANedT62v3IJRi0LTYK0Dua7JuVePzkJxEsRDD8QnSLGlD9eW3EhQJSaDL9QjEz7qO" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>离线版 Chrome下载方法<br> <a href="http://dl.google.com/chrome/install/[版本号后两位]/chrome_installer.exe" target="_blank" rel="external">http:]]>
    </summary>
    
      <category term="Chrome" scheme="http://tiandechi.com/tags/Chrome/"/>
    
      <category term="Browser" scheme="http://tiandechi.com/categories/Browser/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[aptitude concise manual]]></title>
    <link href="http://tiandechi.com/2015/04/18/aptitude-concise-manual/"/>
    <id>http://tiandechi.com/2015/04/18/aptitude-concise-manual/</id>
    <published>2015-04-18T15:56:43.000Z</published>
    <updated>2015-04-18T19:43:30.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://man.ddvip.com/linux/debian/aptitude/index.html" target="_blank" rel="external">aptitude简明手册</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://man.ddvip.com/linux/debian/aptitude/index.html" target="_blank" rel="external">aptitude简明手册</a></p>
]]>
    </summary>
    
      <category term="Aptitude" scheme="http://tiandechi.com/tags/Aptitude/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[check Linux Kernel and Distrabution version]]></title>
    <link href="http://tiandechi.com/2015/04/18/check-Linux-Kernel-and-Distrabution-version/"/>
    <id>http://tiandechi.com/2015/04/18/check-Linux-Kernel-and-Distrabution-version/</id>
    <published>2015-04-18T15:55:19.000Z</published>
    <updated>2015-04-18T07:56:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="查看发行版本：">查看发行版本：</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/etc/i</span>ssue</span><br></pre></td></tr></table></figure>
<h1 id="查看内核版本：">查看内核版本：</h1><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /<span class="keyword">proc</span>/version</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.sina.com.cn/s/blog_66ad86a301015yzr.html" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="查看发行版本：">查看发行版本：</h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><]]>
    </summary>
    
      <category term="Distrabution" scheme="http://tiandechi.com/tags/Distrabution/"/>
    
      <category term="Kernel" scheme="http://tiandechi.com/tags/Kernel/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The role and content of the Linux Directory]]></title>
    <link href="http://tiandechi.com/2015/04/18/The-role-and-content-of-the-Linux-Directory/"/>
    <id>http://tiandechi.com/2015/04/18/The-role-and-content-of-the-Linux-Directory/</id>
    <published>2015-04-18T15:52:12.000Z</published>
    <updated>2015-04-21T02:37:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="根目录“/”">根目录“/”</h1><p>根目录位于目录结构的最顶层，用斜线（/）表示，类似于Windows操作系统的“C:\“，包含Fedora操作系统中所有的目录和文件。</p>
<h1 id="/bin">/bin</h1><p>/bin<br>目录又称为二进制目录，包含了那些供系统管理员和普通用户使用的重要linux命令的二进制映像。该目录存放的内容包括各种可执行文件，还有某些可执行文件的符号连接。常用的命令有：cp、dmesg、kill、login、rm、ping、chomd、bash、cat、echo、ls、 mail、vi等。</p>
<h1 id="/boot">/boot</h1><p>/boot<br>目录存放系统核心文件以及启动时必须读取的文件，包括Linux内核的二进制映像。</p>
<h1 id="/dev">/dev</h1><p>/dev<br>目录保存着外部设备代码的文件，这些文件比较特殊，实际上它们都指向所代表的外围设备，如终端、磁盘驱动器、光驱、打印机等。你可以访问这些外部设备，与访问一个文件或一个目录没有区别。如该目录下的子目录/dev/cdrom表示光驱目录；子目录/dev/console表示控制台；子目录 /dev/fd表示软驱；子目录/dev/hd表示硬盘上的一个分区；lp0表示打印机；ttyS0表示系统的串口设备；dsp表示系统的音箱设备。例如在系统中键入“cd /dev/cdrom”，就可以看到光驱中的文件；键入“cd /dev/mouse”即可看鼠标的相关文件。<br><a id="more"></a></p>
<h1 id="/cdrom">/cdrom</h1><p>该目录在刚安装系统时是空的，你可以将光驱文件系统挂在这个目录下， 例如“mount /dev/cdrom /cdrom”。</p>
<h1 id="/etc">/etc</h1><p>/etc<br>目录是整个Linux系统的中心，其中包含所有系统管理和维护方面的配置文件，如dhcpd.conf、host.conf、logrotate.conf、man.config、mke2fs.conf、modprobe.conf、resolv.conf、sysctl.conf、syslog.conf（或rsyslog.conf）、xinetd.conf和yum.conf等，其他的配置文件分别位于单独的子目录中。通常应注意备份这个目录中的重要配置文件，以便需要是能够快速的恢复系统。用于存放系统的配置文件和特定主机的相关文件。例如，记录用户帐号名称的 password 文件、投影密码的 shadow 文件等。该目录不包含任何二进制文件，并且该目录下的所有文件主要由管理员使用，普通用户只对其具有阅读权限。该目录还包含一些网络配置文件、文件系统、 x系统配置文件、设备配置信息、设置用户信息等。<br>/etc/cron.d<br>用于存储cron进程调度运行后台进程所用的配置和控制文件。其他目录包括/etc/crontab文件定义的cron.hourly、cron.daily、cron.weekly和cron.monthly等四个目录。<br>/etc/cups 用于存储通用UNIX打印系统（Commom UNIX Printing System，CUPS）使用的各种配置文件。<br>/etc/default 其中的文件用于提供部分工具软件（如useradd程序）使用的变量及其默认值。<br>/etc/httpd<br>Apache配置文件的根目录。Apache是一个通用的、高性能的HTTP服务器，也是世界上最流行的Web服务器。Apache采用模块化的设计方式，支持运行时的动态模块选择、虚拟主机，以及服务进程数量的动态调整等。<br>/etc/init.d 用于存储进入相应运行级时需要由init调度执行的脚本文件。在Fedora<br>Linux系统中，这只是一个符号链接文件，实际的目录应为/etc/rc.d/init.d。<br>/etc/ipsec.d 用于存储IPSee使用的配置文件等。<br>/etc/kde 其中含有部分KDE初始化文件和KDM配置文件。<br>/etc/pki 用于存储各种密匙，如用于安装软件包的密匙等。<br>/etc/ppp 用于存储PPP的脚本和配置文件。<br>/etc/profile.d 用于存储/etc/profile等使用的辅助初始化文件，如lang.sh脚本文件等。<br>/etc/rc.d 用于存储进入相应运行级是由init进程调度执行的脚本文件。其中含有init.d和rcN.d等子目录（其中的N为0、1、2、3、4、5和6，表示系统的运行级）。<br>/etc/samba Samba配置文件的根目录。Samba是一个网络共享软件的总称，Linux系统中实现的SMB协议，允许Linux系统为Windows系统提供文件和打印共享服务。<br>/etc/security 用户存储的基本安全控制文件，包括注册控制文件、控制访问控制文件，以及资源限制控制文件等。<br>/etc/selinux SElinux(Security Enhanced Linux，由美国国家安全部(National Security Agency)领导开发的GPL项目，它拥有一个灵活而强制性的访问控制结构，旨在提高Linux系统的安全性，提供强健的安全保证，可防御未知攻击，据称相当于B1级的军事安全性能。比MS<br>NT所谓的C2等高得多。应用SELinux后，可以减轻恶意攻击或恶意软件带来的灾难，并提供对机密性和完整性有很高要求的信息很高的安全保障。)配置文件的根目录。<br>/etc/skel 其中存有默认的初始化文件，如.bash_logout、.bash_profile、.bashrc、.emacs、.kde和.zshrc等。每当新增一个新用户时，系统将会把其中的部分初始化文件复制到用户的主目录中。注意：上述文件均为隐藏文件。(即以“.“开头的文件名)<br>/etc/ssh 这个目录含有系统配置过程，以及系统引导过程中需要用到的各种配置文件，也是chkconfig维护的各种后台服务进程配置文件的根目录。例如，其中的clock文件包含系统的时区设置，keyboard文件包含键盘的类型定义，init文件包含系统引导过程使用的参数定义等。<br>/etc/tomcat5 tomcat的根目录<br>/etc/vsftpd 包含FTP服务器的配置文件，其中包括vsftpd.conf、ftpusers和user_list等重要文件。<br>/etc/xinetd.d 其中包含xinetd服务进程控制的所有传统网络服务使用的配置文件，尤其包含telnet等网络应用的配置文件。在Linux系统中，原有的inetd已由功能更强的xinetd服务进程取代，原有的inetd.conf配置文件也由xinetd.d目录中的一系列单独的配置文件取代。<br>/etc/yum 其中包含yum软件更新工具使用的配置文件。<br>/etc/yum.repos.d其中包含每个软件仓库的配置文件。</p>
<h1 id="/lib">/lib</h1><p>/lib<br>目录下存放必要的运行库，主要是编程语言的库。典型的 Linux 操作系统中包含了C、C++和 Fortran 的库文件。用这些语言开发的应用程序可以使用这些编程语言库文件。这使软件开发者能够利用那些预先写好并通过测试的函数。库文件包含了标准的C库/lib/libc.so.，数学库libm.so.，共享的动态链接库/lib/ld/so以及目录/bin和/sbin下用到的其他共享库。/lib/modules目录存放系统的核心模块，某些可被模块化的部分并不需要在编译系统核心时放入核心本体，避免本体过于庞大而导致效率降低。</p>
<h1 id="/lost+found">/lost+found</h1><p>该目录存放所有和其它目录都没有关联的文件。系统出现错误或发生问题时，Fedora会自动扫描磁盘驱动器，修正错误，如果找到遗失或错误的片段，将这些片段转化成文件存放于此，等待管理员的进一步处理。</p>
<h1 id="/mnt">/mnt</h1><p>该目录是默认的文件系统临时装载点，这是一个通用的安装点，可以临时安装任何文件系统或远程资源。系统管理员执行 mount<br>命令完成装载工作。在系统中，该目录包含了光驱、磁盘和软驱的挂载点。</p>
<h1 id="/proc">/proc</h1><p>进程文件系统proc的根目录，其中的部分文件分别对应正在运行的进程，可用于访问当前进程的地址空间。它是一个非常特殊的虚拟文件系统，其中并不包含“实际的”文件，而是可用以引用当前运行系统的系统信息，如CPU、内存、运行时间、软件配置以及硬件配置的信息，这些信息是在内存中由系统自己产生的。<br>/proc/net 其中的文件分别表示各种网络协议（如TCP、UDP以及ARP等）的状态与统计信息。<br>/proc/sys 这个目录不仅存有各种系统信息，而且也包含系统内核与TCP/IP网络的可调参数。其中的kernel子目录含有共享内存和消息队列的可调参数，net子目录中含有TCP/IP的各种可调参数。例如，shmmax文件中含有系统的最大共享内存定义，如果使用“echo somevalue &gt;<br>/proc/sys/kernel/shmmax”命令，可以直接修改运行系统的内核参数，而无需重新引导系统。这一做法要谨慎，有的文件可能包含多个数值，或不同类型的数值，因此，在修改以前一定要弄清参数的意义和实际的数值。为了在每次启动系统时都能使用定制的系统可调参数，可以设置sysctl.conf配置文件，或编写自己的Shell启动脚本。</p>
<h1 id="/opt">/opt</h1><p>/opt<br>目录用来安装附加软件包，用户调用软件包程序放在目录/opt/package_name/bin下，package_name是安装软件包的名称。</p>
<h1 id="/root">/root</h1><p>超级用户root的主目录（在Linux系统中，斜杠字符“/”是整个系统的根目录，而非超级用户的主目录。）</p>
<h1 id="/sbin">/sbin</h1><p>目录/sbin、/usr/sbin和/usr/local/sbin存放了该目录启动系统时需执行的程序，如管理工具、应用软件和通用的根用户权限命令等内容。如包含getty、init、update</p>
<p><a href="http://www.linuxidc.com/Linux/2015-04/116032.htm" target="_blank" rel="external">来源</a></p>
<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%"><br><tbody><tr align="center" bgcolor="#182448"><td width="80"><font color="#FFFFFF">目录</font></td><td><font color="#FFFFFF">应放置文件内容</font></td></tr><br><tr><td>/bin</td><td><br>    系统有很多放置执行文件的目录，但/bin比较特殊。因为<span class="text_import2">/bin放置的是在单人维护模式下还能够被操作的指令。</span><br>    在/bin底下的指令可以被root与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</td></tr><br><tr><td>/boot</td><td><br>    这个目录主要在放置开机会使用到的文件，包括Linux核心文件以及开机选单与开机所需配置文件等等。<br>    <span class="text_import2">Linux kernel常用的档名为：vmlinuz</span>，如果使用的是grub这个开机管理程序，<br>    则还会存在/boot/grub/这个目录喔！</td></tr><br><tr><td>/dev</td><td><br>    在Linux系统上，任何装置与接口设备都是以文件的型态存在于这个目录当中的。<br>    你只要透过存取这个目录底下的某个文件，就等于存取某个装置啰～<br>    比要重要的文件有<span class="text_import2">/dev/null, /dev/zero, /dev/tty</span>, /dev/lp<em>, /dev/hd</em>, /dev/sd<em>等等</em></td></tr><br><tr><td>/etc</td><td><br>    系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、<br>    各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的，<br>    但是只有root有权力修改。<span class="text_import2">FHS建议不要放置可执行文件(binary)在这个目录中</span>喔。比较重要的文件有：<br>    <span class="text_import2">/etc/inittab, /etc/init.d/, /etc/modprobe.conf,<br>    /etc/X11/, /etc/fstab, /etc/sysconfig/</span> 等等。另外，其下重要的目录有：<br>    <ul><li><span class="text_import2">/etc/init.d/</span>：所有服务的预设启动 script<br>        都是放在这里的，例如要启动或者关闭 iptables 的话：『 /etc/init.d/iptables start』、『/etc/init.d/iptables<br>        stop』</li><br>    <li><span class="text_import2">/etc/xinetd.d/</span>：这就是所谓的super daemon管理的各项服务的配置文件目录。</li><br>    <li><span class="text_import2">/etc/X11/</span>：与 X Window 有关的各种配置文件都在这里，尤其是<br>        xorg.conf 这个 X Server 的配置文件。</li></ul></td></tr><br><tr><td>/home</td><td><br>    这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时，<br>    默认的用户家目录都会规范到这里来。比较重要的是，家目录有两种代号喔：<br><br>    <span class="text_import2">~</span>：代表目前这个用户的家目录，而 <br><br>    <span class="text_import2">~dmtsai</span> ：则代表 dmtsai 的家目录！</td></tr><br><tr><td>/lib</td><td><br>    系统的函式库非常的多，而<span class="text_import2">/lib放置的则是在开机时会用到的函式库，<br>    以及在/bin或/sbin底下的指令会呼叫的函式库而已</span>。<br>    什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。<br>    尤其重要的是<span class="text_import2">/lib/modules/</span>这个目录，<br>    因为该目录会放置核心相关的模块(驱动程序)喔！</td></tr><br><tr><td>/media</td><td><br>    media是『媒体』的英文，顾名思义，这个<span class="text_import2">/media底下放置的就是可移除的装置啦！</span><br>    包括软盘、光盘、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。</td></tr><br><tr><td>/mnt</td><td><br>    如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。<br>    在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</td></tr><br><tr><td>/opt</td><td><br>    这个是<span class="text_import2">给第三方协力软件放置的目录</span>。什么是第三方协力软件啊？<br>    举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。<br>    另外，如果妳想要自行安装额外的软件(非原本的distribution提供的)，那么也能够将你的软件安装到这里来。<br>    不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！</td></tr><br><tr><td>/root</td><td><br>    系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，<br>    该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分割槽中。</td></tr><br><tr><td>/sbin</td><td><br>    Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。<br>    <span class="text_import2">放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。</span><br>    至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统执行文件(system binary)，<br>    则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。</td></tr><br><tr><td>/srv</td><td><br>    srv可以视为『service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。<br>    常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。</td></tr><br><tr><td>/tmp</td><td><br>    这是让一般使用者或者是正在执行的程序暂时放置文件的地方。<br>    这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！<br>    因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</td></tr><br><tr><td>/lost+found</td><td><br>    这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时，<br>    将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在，<br>    例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』</td></tr><br><tr><td>/proc</td><td><br>    这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中，<br>    例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中，<br>    所以本身不占任何硬盘空间啊！比较重要的文件例如：<span class="text_import2">/proc/cpuinfo,<br>    /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/</span> 等等。</td></tr><br><tr><td>/sys</td><td><br>    这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的信息。<br>    包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量喔！</td></tr><br></tbody><br></table>

<p><a href="http://vbird.dic.ksu.edu.tw/linux_basic/0210filepermission_3.php" target="_blank" rel="external">来源</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="根目录“/”">根目录“/”</h1><p>根目录位于目录结构的最顶层，用斜线（/）表示，类似于Windows操作系统的“C:\“，包含Fedora操作系统中所有的目录和文件。</p>
<h1 id="/bin">/bin</h1><p>/bin<br>目录又称为二进制目录，包含了那些供系统管理员和普通用户使用的重要linux命令的二进制映像。该目录存放的内容包括各种可执行文件，还有某些可执行文件的符号连接。常用的命令有：cp、dmesg、kill、login、rm、ping、chomd、bash、cat、echo、ls、 mail、vi等。</p>
<h1 id="/boot">/boot</h1><p>/boot<br>目录存放系统核心文件以及启动时必须读取的文件，包括Linux内核的二进制映像。</p>
<h1 id="/dev">/dev</h1><p>/dev<br>目录保存着外部设备代码的文件，这些文件比较特殊，实际上它们都指向所代表的外围设备，如终端、磁盘驱动器、光驱、打印机等。你可以访问这些外部设备，与访问一个文件或一个目录没有区别。如该目录下的子目录/dev/cdrom表示光驱目录；子目录/dev/console表示控制台；子目录 /dev/fd表示软驱；子目录/dev/hd表示硬盘上的一个分区；lp0表示打印机；ttyS0表示系统的串口设备；dsp表示系统的音箱设备。例如在系统中键入“cd /dev/cdrom”，就可以看到光驱中的文件；键入“cd /dev/mouse”即可看鼠标的相关文件。<br>]]>
    
    </summary>
    
      <category term="Directory" scheme="http://tiandechi.com/tags/Directory/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ssh add command]]></title>
    <link href="http://tiandechi.com/2015/04/18/ssh-add-command/"/>
    <id>http://tiandechi.com/2015/04/18/ssh-add-command/</id>
    <published>2015-04-18T15:49:56.000Z</published>
    <updated>2015-04-18T07:52:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="功能作用">功能作用</h1><p>把专用密钥添加到 ssh-agent 的高速缓存中</p>
<h1 id="位置">位置</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssh-<span class="keyword">add</span></span><br></pre></td></tr></table></figure>
<h1 id="格式用法">格式用法</h1><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="built_in">add</span> [-cDdLlXx] [-t life] [<span class="built_in">file</span> ...]</span><br><span class="line">ssh-<span class="built_in">add</span> -s pkcs11</span><br><span class="line">ssh-<span class="built_in">add</span> -e pkcs11</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="主要参数">主要参数</h1><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">c     <span class="constant">Indicates</span> that added identities should be subject to confirmation</span><br><span class="line"></span>before being used for authentication.  Confirmation is performed</span><br><span class="line">by the SSH_ASKPASS program mentioned below.  Successful confirma‐</span><br><span class="line">tion is signaled by a zero exit status from the SSH_ASKPASS pro‐</span><br><span class="line">gram, rather than text entered into the requester.</span><br><span class="line">-<span class="ruby"><span class="constant">D</span>    删除ssh-agent中的所有密钥.</span><br><span class="line"></span>-<span class="ruby">d    从ssh-agent中的删除密钥</span><br><span class="line"></span>-<span class="ruby">e    pkcs11 <span class="comment">#删除PKCS#11共享库pkcs1提供的钥匙。</span></span><br><span class="line"></span>-<span class="ruby">s    pkcs11 <span class="comment">#添加PKCS#11共享库pkcs1提供的钥匙。</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">L</span>    显示ssh-agent中的公钥</span><br><span class="line"></span>-<span class="ruby">l    显示ssh-agent中的密钥</span><br><span class="line"></span>-<span class="ruby">t    life <span class="comment">#对加载的密钥设置超时时间，超时ssh-agent将自动卸载密钥</span></span><br><span class="line"></span>-<span class="ruby"><span class="constant">X</span>    对ssh-agent进行解锁</span><br><span class="line"></span>-<span class="ruby">x    对ssh-agent进行加锁</span></span><br></pre></td></tr></table></figure>
<h1 id="应用实例">应用实例</h1><ol>
<li><p>把专用密钥添加到 ssh-agent 的高速缓存中</p>
 <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span> ~/.ssh/id_dsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>从ssh-agent中删除密钥</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span> -d ~/.ssh/id_xxx.pub</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看ssh-agent中的密钥</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">add</span> -l</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="http://www.lampblog.net/ubuntu/ssh-add%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">ssh-add命令</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="功能作用">功能作用</h1><p>把专用密钥添加到 ssh-agent 的高速缓存中</p>
<h1 id="位置">位置</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ssh-<span class="keyword">add</span></span><br></pre></td></tr></table></figure>
<h1 id="格式用法">格式用法</h1><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="built_in">add</span> [-cDdLlXx] [-t life] [<span class="built_in">file</span> ...]</span><br><span class="line">ssh-<span class="built_in">add</span> -s pkcs11</span><br><span class="line">ssh-<span class="built_in">add</span> -e pkcs11</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="SSH" scheme="http://tiandechi.com/tags/SSH/"/>
    
      <category term="Linux" scheme="http://tiandechi.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git SSH key Generate]]></title>
    <link href="http://tiandechi.com/2015/04/18/Git-SSH-key-Generate/"/>
    <id>http://tiandechi.com/2015/04/18/Git-SSH-key-Generate/</id>
    <published>2015-04-18T15:46:45.000Z</published>
    <updated>2015-05-12T16:30:49.868Z</updated>
    <content type="html"><![CDATA[<p>Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。</p>
<h1 id="设置Git的user_name和email：">设置Git的user name和email：</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user<span class="class">.name</span> <span class="string">"my"</span></span><br><span class="line">$ git config --global user<span class="class">.email</span> <span class="string">"my@email.address"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="生成SSH密钥过程：">生成SSH密钥过程：</h1><ol>
<li><p>查看是否已经有了ssh密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>
<p>如果没有密钥则不会有此文件夹，有则备份删除</p>
</li>
<li><p>生成密钥：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “my<span class="annotation">@email</span>.address”</span><br><span class="line">#会有三个提示： 指定存放位置 密钥 确认密钥</span><br><span class="line">#均按回车键就可以跳过，并以默认保存啦</span><br><span class="line">#结果是：</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> <span class="regexp">/home/</span>tekkub<span class="regexp">/.ssh/</span>id_rsa.</span><br><span class="line">Your <span class="keyword">public</span> key has been saved <span class="keyword">in</span> <span class="regexp">/home/</span>tekkub<span class="regexp">/.ssh/</span>id_rsa.pub.</span><br><span class="line">The key fingerprint <span class="string">is:</span></span><br><span class="line">………………</span><br></pre></td></tr></table></figure>
<p>最后得到了两个文件：id_rsa 和 id_rsa.pub</p>
</li>
<li><p>添加专用密钥到 ssh：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[ssh-add命令详解](http://tiandechi.com/2015/04/14/ssh-add-command/)</span></span><br><span class="line"><span class="variable">$ </span>ssh-add ~<span class="regexp">/.ssh/id</span>_rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。<br>打开github ，登陆账号，然后在 设置-SSH keys 中添加“id_rsa.pub” 的全部内容。</p>
</li>
<li>测试：<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git<span class="annotation">@github</span>.com</span><br><span class="line">The authenticity of host ‘github.com (<span class="number">207.97</span>.227.239)’ can’t be established.</span><br><span class="line">RSA key fingerprint is <span class="number">16</span>:<span class="number">27</span>:<span class="string">ac:</span><span class="string">a5:</span><span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span><span class="string">d:</span><span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span><span class="string">b:</span><span class="number">56</span>:<span class="number">4</span><span class="string">d:</span><span class="string">eb:</span><span class="string">df:</span><span class="string">a6:</span><span class="number">48.</span></span><br><span class="line">Are you sure you want to <span class="keyword">continue</span> connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added ‘github.com,<span class="number">207.97</span>.227.239′ (RSA) to the list of known hosts.</span><br><span class="line"><span class="string">ERROR:</span> Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell access</span><br><span class="line">Connection to github.com closed.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="愉快的使用_github_吧！">愉快的使用 github 吧！</h1><p><a href="http://blog.csdn.net/hustpzb/article/details/8230454/" target="_blank" rel="external">Git SSH Key 生成步骤</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。</p>
<h1 id="设置Git的user_name和email：">设置Git的user name和email：</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user<span class="class">.name</span> <span class="string">"my"</span></span><br><span class="line">$ git config --global user<span class="class">.email</span> <span class="string">"my@email.address"</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Git" scheme="http://tiandechi.com/tags/Git/"/>
    
      <category term="SSH" scheme="http://tiandechi.com/tags/SSH/"/>
    
  </entry>
  
</feed>